<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/04/18/day01%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/18/day01%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>今日内容介绍<br>1、Java开发环境搭建<br>2、HelloWorld案例<br>3、注释、关键字、标识符<br>4、数据（数据类型、常量）</p><p>###01java语言概述<br>    * A: java语言概述<br>        * a: Java是sun公司开发的一门编程语言,目前被Oracle公司收购，编程语言就是用来编写软件的。<br>        * b: Java的应用<br>            * 开发QQ、迅雷程序(桌面应用软件)<br>            * 淘宝、京东(互联网应用软件)<br>        * c: Java的擅长<br>            * 互联网：电商、P2P等等<br>            * 企业级应用：ERP、CRM、BOS、OA等等<br>        * d: Java语言平台<br>            * JavaSE（标准版）部分,基础班学习JavaSE,JavaSE并不能开发大型项目。<br>            * JavaEE（企业版）部分,就业班学习JavaEE,学习完JavaEE部分就可以开发各种大型项目了。</p><p>###02常用的DOS命令<br>    * A: 常用的DOS命令<br>        * a: 打开Dos控制台<br>            * win+r–cmd–回车<br>        * b: 常用dos命令<br>            * cd.. : 退回到上一级目录<br>            * cd\  : 退回到根目录<br>            * cd tools: 进入tools文件夹<br>            * d:   : 回车    盘符切换<br>            * cd d:\234 :进入d盘的234文件夹,再切换盘符(d:)才能进入d:\234<br>            * dir  : 列出当前目录下的文件以及文件夹<br>            * cls  : 清除屏幕<br>            * ipconfig: 查看本机的相关网络配置<br>        * c: dos控制台运行记事本程序<br>            * D:&gt;C:\windows\notepad.exe<br>            * 还可以省略“.exe”后缀，例如：D:&gt;C:\windows\notepad</p><p>###03java语言开发环境JDK<br>    * A: java语言开发环境JDK<br>        * a: JDK是Java开发环境<br>        * b: 课程中使用的JDK版本是JDK7，当前最新版本是JDK8</p><p>###04JDK的下载和安装<br>    * A: JDK的下载<br>        * a: 官网 <a href="http://www.oracle.com/cn/index.html">http://www.oracle.com/cn/index.html</a><br>        * b: 演示下载流程<br>    * B: JDK的安装<br>        * a: 傻瓜式安装<br>            * 双击安装程序，然后一路next即可(但是不建议)<br>        * b: 安装的推荐方式<br>            * 安装路径不要有中文或者特殊符号如空格等。<br>            * 所有和开发相关的软件最好安装目录统一。<br>                * 举例：我的JDK安装路径<br>                    * D:\develop\Java\jdk1.7.0_72<br>            * 当提示安装JRE时，可以选择不安装。建议还是安装上。<br>                    * D:\develop\Java\jre<br>            * 安装路径中没有的文件夹,会自动创建</p><pre><code>* C: 验证安装是否成功    * a:通过DOS命令，切换到JDK安装的bin目录下。        * D:\develop\Java\jdk1.7.0_72\bin    * b:然后分别输入javac和java，如果正常显示一些内容，说明安装成功</code></pre><p>###05JDK和JRE跨平台<br>    * A: JDK与JRE的关系<br>        * a: JDK：它是Java开发运行环境，在程序员的电脑上当然要安装JDK；<br>        * b: JRE：Java Runtime Environment它是Java运行环境，如果你不需要开发只需要运行Java程序，那么你可以安装JRE。例如程序员开发出的程序最终卖给了用户，用户不用开发，只需要运行程序，所以用户在电脑上安装JRE即可。<br>        * c: JDK包含了JRE。<br>    * B: 跨平台特性<br>        * a: 平台指的是操作系统 （Windows，Linux，Mac）。<br>        * b: Java程序可以在任意操作系统上运行，一次编写到处运行<br>        * c: 实现跨平台需要依赖Java的虚拟机 JVM （Java Virtual Machine）</p><p>###06编写HelloWorld程序<br>    * A: 编写步骤(初学者)<br>        * a: 创建一个普通文本文件，将其修改为.java文件。<br>        * b: 完成模板代码：<br>            public class HelloWorld{<br>                public static void main(String[] args) {<br>                        System.out.println(“Hello World!”);<br>                }<br>            }<br>    * B: 实际开发步骤<br>        * a: 定义类<br>        * b: 写main方法<br>        * c: 写输出语句(注意：下面的代码是原代码，是不能运行的)<br>            public class HelloWorld {<br>                public static void main(String[] args) {<br>                    System.out.println(“HelloWorld”);<br>                }<br>            }<br>        * d：注意：<br>            * 不要隐藏文件的扩展名<br>            * 类名和文件名要保持一致<br>    * C: Java代码的编写执行过程<br>        * a: 源文件：编写Java源文件（我们也称之为源代码文件），它的扩展名为.java；<br>        * b: 编译：然后通过编译器把源文件编译成字节码文件，字节码文件扩展名为.class；<br>        * c: 运行：最后使用解释器来运行字节码文件。</p><p>###07编译Java程序<br>    * A：程序编译<br>        * 作用：将程序员写的java源代码生成可以运行的Java程序(.class文件)<br>        * 过程：<br>            * a:开启DOS窗口并切换到.java文件所在的目录 比如HelloWord.java存放于d:\234\day01\code 中<br>            * b:切换到HelloWorld.java所在目录,但是此目录中没有javac命令,所以在编译时要写出javac命令的全路径<br>            * c: d:\234\day01\code&gt;d:\develop\java\jdk1.7.0_72\bin\javac HelloWorld.java 回车<br>            * d:在d:\234\day01\code文件夹中多了个HelloWorld.class文件(又叫做字节码文件)</p><p>###08运行Java程序<br>    * A：运行程序<br>        * a: 开启DOS窗口并切换到.class文件所在的目录<br>        * b: 此目录中没有java命令,所以在运行时也要写出java命令的全路径<br>        * c: d:\234\day01\code&gt;d:\develop\java\jdk1.7.0_72\bin\java HelloWorld 回车(注意:运行时不用后缀名.class)<br>        * d: 控制台打印显示结果”HelloWorld”</p><p>###09环境变量的配置<br>    * A: Path环境变量配置方式一<br>        * a: 安装高级文本编辑器notepad++<br>        * b: 配置Windows的path环境变量<br>            * 环境变量的作用：让Java的bin目录下的javac命令可以在任意目录下执行<br>            * 配置方法：<br>                * 右键点击计算机  →  选择属性  →  更改设置  →  点击高级  →  点击环境变量  →  找到系统变量中的path  →  将java安装目录下javac所在的bin目录路径配置到path变量中，用；(英文)与其他变量分隔<br>            * 注意：<br>                * 配置path后文件的访问顺序：先访问当前路径，如果当前路径没有该文件，则再访问path配置的路径<br>    * B:配置过程(建议使用这种方式配置)<br>        * a：右键点击计算机  →  选择属性  →  更改设置  →  点击高级  →  点击环境变量  →  创建名为JAVA_HOME的环境变量  →  将jdk所在的目录路径(bin所在的路径)配置到JAVA_HOME变量中<br>        * b: 用;与其他变量分隔  →  在path环境变量中添加%JAVA_HOME%\bin</p><p>###10notepad软件安装<br>    * A: 安装<br>        * 双击.exe文件安装 即可</p><p>###11注释<br>    * A: 注释<br>        * a: 定义：用来解释和说明程序的文字，注释是不会被执行的<br>        * b: 分类：<br>            * 1：单行注释    //注释内容<br>            * 2：多行注释    /<em>注释内容</em>/<br>            * 3：文档注释    /<em><em>注释内容</em>/<br>        * c: 注意：<br>            * 1：对于单行和多行注释，被注释的文字，不会被JVM解释执行<br>            * 2：对于文档注释，可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档<br>            * 3：单行注释可以嵌套使用，多行注释不能嵌套使用<br>        * d: 案例代码<br>            /</em><br>                 实现了一个Java的HelloWorld程序<br>                 实现步骤：<br>                   1. 定义类<br>                   2. 定义主方法<br>                   3. 一条命令，控制台输出了HelloWorld<br>            */<br>            public class HelloWorld{<br>                //main主方法，固定格式，程序的入口点<br>                public static void main(String[] args){<br>                    //系统 输出 打印    打印的内容<br>                    System.out.println(“HelloWorld”);<br>                }<br>            }<br>###12关键字<br>    * A: 关键字<br>        * a: 定义<br>            * 是被Java语言赋予特殊含义，具有专门用途的单词，比如之前接触的class，int，double均为Java已经预设好的<br>        * b: 特点<br>            * 组成关键字的字母全部小写(代码中的蓝色部分) ,注意String不是关键字<br>        * c: 常见关键字<br>            * public static void class等<br>        * d: 注意事项<br>            * goto与const是Java中的保留字，即没有赋予特殊含义却仍被Java占用的单词,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 </p><p>###13标识符<br>    * A: 标识符<br>        * a: 定义<br>            * 就是给类,接口,方法,变量等起名字时使用的字符序列<br>        * b: 组成规则(只能包含下面的内容,不能有其它内容)<br>            * 1: 英文大小写字母<br>            * 2：数字字符<br>            * 3：$和_<br>        * c: 注意事项<br>            * 1：数字不能开头<br>            * 2：不可以使用关键字<br>            * 3：严格区分大小写，不限制长度<br>            * 4：起名时，尽量达到见名知意<br>    * B：标识符中常见的命名规则(这些规定是不受语法约束的)<br>        * a: 包名：多单词组成时所有字母均小写，使用.连接  aaa.bbb.ccc<br>        * b: 类名&amp;接口名：大驼峰式   AaaBbbCcc<br>        * c: 变量名&amp;方法名：小驼峰式   aaaBbbCcc<br>        * d: 常量名：多单词组成是所有字母均大写，使用_连接AAA_BBB_CCC<br>    * C: 案例代码<br>        /*<br>           标识符<br>           Java中，自己定义的内容<br>           自定义类的名字，上一个案例 HelloWorld<br>           标识符的规则：<br>             组成： 字母52个A-Z a-z 数字0-9 _ 下划线 $ 美元符</p><pre><code>         注意： 不能数字开头，不能是关键字                  定义名字：            _abc  0a  a0  a#a  a$a   void             YES  NO  YES NO   YES   NO                      类的名字： 首字母大写，第二个单词首字母大写          BeiJingShiHaiDianQuYiYuan          MeiGuoJiaLiFuNiYa                  方法的名字：首字母小写，每个单词首字母大写           addStudent      */    public class Demo&#123;            &#125;</code></pre><p>###14Java中的数据类型<br>    * A:为什么有数据类型<br>        * Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型<br>    * B:Java中数据类型的分类<br>        * 基本数据类型: 基本数据类型是Java语言中内置的类型，分别是整数类型、小数类型、字符类型、布尔类型。<br>            这四类基本类型是最简单、最基础的类型。<br>            * 整数(byte、short、int、long)、小数(float、double)、字符类型(char)、布尔类型(boolean)<br>        * 引用数据类型: 是强大的数据类型，它是基于基本数据类型创建的。JavaSE中提供了一个超级类库，类库中包含了近万种引用数据类型。<br>            不过现在我们先要学习的是基本类型！<br>            * 数组、类、接口</p><p>###15Java中的常量<br>    * A: 常量的定义<br>        * 常量就是不变的数据量, 在程序执行的过程中其值不可以发生改变<br>    * B: 常量分类<br>        * a: 整数类型<br>            * 十进制表示方式：正常数字   如 13、25等<br>            * 二进制表示方式：以0b(0B)开头    如0b1011 、0B1001<br>            * 十六进制表示方式：以0x(0X)开头   数字以0-9及A-F组成  如0x23A2、0xa、0x10<br>            * 八进制表示方式：以0开头   如01、07、0721<br>        * b: 小数类型<br>            * 如1.0、-3.15、3.168等<br>        * c: 布尔类型<br>            * true、false<br>        * d: 字符类型<br>            * 如’a’，’A’, ‘0’, ‘家’<br>            * 字符必须使用’’ 包裹，并且其中只能且仅能包含一个字符。<br>        * e: 字符串类型<br>            * 字符串String类型是一种引用类型，我们先了解作为常量类型的使用方式<br>            * 如“我爱Java”，“0123”，“”，“null”<br>            * 字符串必须使用“”包裹，其中可以包含0~N个字符。</p><p>###16程序中输出Java中的常量<br>    * A: 案例代码<br>        /*<br>           Demo_1类，演示Java中的所有类型的常量<br>           程序当中输出：<br>             输出整数常量<br>             小数常量<br>             布尔常量<br>             字符常量<br>             字符串常量<br>        */<br>        public class Demo_1{<br>            public static void main(String[] args){<br>                //输出整数 十进制<br>                System.out.println(50);</p><pre><code>            //输出整数，二进制, 数字开头0B            System.out.println(0B11);                        //输出整数，八进制，数字开头0            System.out.println(051);                        //输出整数，十六进制，数组开头0X  0-9 A-F            System.out.println(0XE);                        //输出浮点数据            System.out.println(5.0);                        //输出布尔数据，只有2个值，true，false 关键字            System.out.println(true);            System.out.println(false);                        //输出字符常量，单引号包裹，只能写1个字符            System.out.println(&#39;a&#39;);                        //输出字符串常量，双引号包裹，可以写0-n个字符            System.out.println(&quot;HelloWorld&quot;);        &#125;    &#125;</code></pre><p>###17总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/04/18/%E5%8A%9B%E6%89%A33/"/>
      <url>2021/04/18/%E5%8A%9B%E6%89%A33/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>21合并两个有序链表<br>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">方法一：递归</span><br><span class="line">思路</span><br><span class="line"></span><br><span class="line">我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</span><br><span class="line"></span><br><span class="line">list1[<span class="number">0</span>]+merge(list1[<span class="number">1</span>:],list2)</span><br><span class="line">list2[<span class="number">0</span>]+merge(list1,list2[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">list1[<span class="number">0</span>]&lt;list2[<span class="number">0</span>]</span><br><span class="line">otherwise</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</span><br><span class="line"></span><br><span class="line">算法</span><br><span class="line"></span><br><span class="line">我们直接将以上递归过程建模，同时需要考虑边界情况。</span><br><span class="line"></span><br><span class="line">如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">思路：栈</span><br><span class="line">解题思路：</span><br><span class="line">算法原理</span><br><span class="line"></span><br><span class="line">栈先入后出特点恰好与本题括号排序特点一致，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 stack 仍然为空；</span><br><span class="line">建立哈希表 dic 构建左右括号对应关系：keykey 左括号，valuevalue 右括号；这样查询 <span class="number">22</span> 个括号是否对应只需 O(<span class="number">1</span>)O(<span class="number">1</span>) 时间复杂度；建立栈 stack，遍历字符串 s 并按照算法流程一一判断。</span><br><span class="line">算法流程</span><br><span class="line"></span><br><span class="line">如果 c 是左括号，则入栈 pushpush；</span><br><span class="line">否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 c 不对应，则提前返回 falsefalse。</span><br><span class="line">提前返回 falsefalse</span><br><span class="line"></span><br><span class="line">提前返回优点： 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。</span><br><span class="line">解决边界问题：</span><br><span class="line">栈 stack 为空： 此时 stack.pop() 操作会报错；因此，我们采用一个取巧方法，给 stack 赋初值 ?? ，并在哈希表 dic 中建立 key: <span class="string">&#x27;?&#x27;</span>，value:<span class="string">&#x27;?&#x27;</span>key: ′ ? ′，value: ′ ? ′ 的对应关系予以配合。此时当 stack 为空且 c 为右括号时，可以正常提前返回 falsefalse；</span><br><span class="line">字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，但 stack 中遗留未出栈的左括号；因此，最后需返回 len(stack) == <span class="number">1</span>，以判断是否是有效的括号组合。</span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度 O(N)O(N)：正确的括号组合需要遍历 <span class="number">11</span> 遍 s；</span><br><span class="line">空间复杂度 O(N)O(N)：哈希表和栈使用线性的空间大小。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Character&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>); put(<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>); put(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>); put(<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">0</span> &amp;&amp; !map.containsKey(s.charAt(<span class="number">0</span>))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;Character&gt;() &#123;&#123; add(<span class="string">&#x27;?&#x27;</span>); &#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c)) stack.addLast(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(map.get(stack.removeLast()) != c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">思路：栈</span><br><span class="line"><span class="number">1</span>、对于奇数个的字符串，一定是错的，因为正确的都成对儿</span><br><span class="line"><span class="number">2</span>、建立栈Stack&lt;Character&gt; a = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="number">3</span>、循环体（遍历字符串）&#123;</span><br><span class="line">找到当前未知的字符</span><br><span class="line">若当前字符是左括号( &#123; [:压栈push</span><br><span class="line">右括号：</span><br><span class="line">（<span class="number">1</span>）栈是否为空  空：<span class="keyword">false</span></span><br><span class="line">（<span class="number">2</span>）找到栈顶字符preChar是否和theChar对应  对应继续循环</span><br><span class="line">（<span class="number">3</span>）不对应退出循环。<span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>、<span class="keyword">return</span> a.empty()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; a = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> theChar = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(theChar==<span class="string">&#x27;&#123;&#x27;</span>||theChar==<span class="string">&#x27;[&#x27;</span>||theChar==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                a.push(theChar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a.empty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> preChar = a.peek();</span><br><span class="line">                <span class="keyword">if</span>((preChar==<span class="string">&#x27;&#123;&#x27;</span>&amp;&amp;theChar==<span class="string">&#x27;&#125;&#x27;</span>)||(preChar==<span class="string">&#x27;[&#x27;</span>&amp;&amp;theChar==<span class="string">&#x27;]&#x27;</span>)||(preChar==<span class="string">&#x27;(&#x27;</span>&amp;&amp;theChar==<span class="string">&#x27;)&#x27;</span>))&#123;</span><br><span class="line">                    a.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、思路</span><br><span class="line"><span class="number">2</span>、标签：链表</span><br><span class="line"><span class="number">3</span>、当字符串数组长度为 <span class="number">0</span> 时则公共前缀为空，直接返回</span><br><span class="line"><span class="number">4</span>、令最长公共前缀 ans 的值为第一个字符串，进行初始化</span><br><span class="line"><span class="number">5</span>、遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀</span><br><span class="line"><span class="number">6</span>、如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回</span><br><span class="line"><span class="number">7</span>、时间复杂度：O(s)O(s)，s 为所有字符串的长度之和</span><br><span class="line"><span class="number">8</span>、代码</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String ans = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;strs.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;ans.length() &amp;&amp; j &lt; strs[i].length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.charAt(j) != strs[i].charAt(j))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(<span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span>(ans.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leetcode 830<br>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p><p>分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</p><p>找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;abbxxxxzzy&quot;</span></span><br><span class="line">输出：[[<span class="number">3</span>,<span class="number">6</span>]]</span><br><span class="line">解释：<span class="string">&quot;xxxx&quot;</span> 是一个起始于 <span class="number">3</span> 且终止于 <span class="number">6</span> 的较大分组。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span> 和 <span class="string">&quot;c&quot;</span> 均不是符合要求的较大分组。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;abcdddeeeeaabbbcd&quot;</span></span><br><span class="line">输出：[[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">9</span>],[<span class="number">12</span>,<span class="number">14</span>]]</span><br><span class="line">解释：较大分组为 <span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;eeee&quot;</span> 和 <span class="string">&quot;bbb&quot;</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;aba&quot;</span></span><br><span class="line">输出：[]</span><br><span class="line">思路：</span><br><span class="line">遍历列表一次：</span><br><span class="line">&#123;</span><br><span class="line">判断是不是到末尾了或者后一个字符与前一个字符不同</span><br><span class="line">是：</span><br><span class="line">若重复元素个数大于<span class="number">3</span>：ist扩展</span><br><span class="line">num置<span class="number">1</span>，从下一个元素作为起始位置</span><br><span class="line">否：</span><br><span class="line">num++说明下一个字符和前一个字符相同且没到末尾，num计数加一</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return</span></span><br><span class="line">注意：java字符串的索引  s.charAt()  </span><br><span class="line"> List&lt;Integer&gt;列表的创建  </span><br><span class="line"> List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(); <span class="comment">//List&lt;Integer&gt;是类型</span></span><br><span class="line">  List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  list.add()</span><br><span class="line">  list.remove() </span><br><span class="line">  ret.add(Arrays.asList(i - num + <span class="number">1</span>, i))</span><br><span class="line">  这些方法的使用很重要</span><br><span class="line">                                                                                                                                                                                                                                                                                                                                          </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span> || s.charAt(i) != s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    ret.add(Arrays.asList(i - num + <span class="number">1</span>, i));</span><br><span class="line">                &#125;</span><br><span class="line">                num = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>力扣435：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br>示例 1:</p><p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p><p>输出: 1</p><p>解释: 移除 [1,3] 后，剩下的区间没有重叠。<br>示例 2:</p><p>输入: [ [1,2], [1,2], [1,2] ]</p><p>输出: 2</p><p>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<br>示例 3:</p><p>输入: [ [1,2], [2,3] ]</p><p>输出: 0</p><p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><p>解题思路：常规的区间问题一般都是通过这样的思路进行解决，就是先根据起点进行排序，然后用一个指针获取前一个区间，用于比较，再遍历数组，。</p><p>如果遇到覆盖，就肯定需要删除一个区间，同时更新指针，因为需要尽可能不会与后面的区间再产生重叠，所以需要保留区间小的；<br>如果没有覆盖，那么将指针更新为当前区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 依据左端点进行排序</span></span><br><span class="line">        Arrays.sort(val, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = val.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置cur为起始区间</span></span><br><span class="line">        <span class="keyword">int</span>[] cur = val[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 遍历所有区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 比较当前区间和前一个区间是否重合</span></span><br><span class="line">            <span class="keyword">if</span>(val[i][<span class="number">0</span>] &lt; cur[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 产生了重合，那肯定需要删除一个区间</span></span><br><span class="line">                res ++;</span><br><span class="line">                <span class="comment">// 更新cur区间，旨在保留长度小的区间，这样尽可能不会与后面的区间再产生重叠</span></span><br><span class="line">                cur[<span class="number">1</span>] = Math.min(val[i][<span class="number">1</span>], cur[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有产生重合，那么将当cur更新为当前区间</span></span><br><span class="line">                cur = val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按照题目的描述，可以总结如下规则：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">罗马数字由 I,V,X,L,C,D,M 构成；</span></span><br><span class="line"><span class="comment">当小值在大值的左边，则减小值，如 IV=5-1=4；</span></span><br><span class="line"><span class="comment">当小值在大值的右边，则加小值，如 VI=5+1=6；</span></span><br><span class="line"><span class="comment">由上可知，右值永远为正，因此最后一位必然为正。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum = getValue(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = getValue(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(preNum &lt; num) &#123;</span><br><span class="line">                sum -= preNum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += preNum;</span><br><span class="line">            &#125;</span><br><span class="line">            preNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += preNum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：donespeak</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/04/18/%E5%8A%9B%E6%89%A32/"/>
      <url>2021/04/18/%E5%8A%9B%E6%89%A32/</url>
      
        <content type="html"><![CDATA[<h2 id="力扣1232-缀点成线"><a href="#力扣1232-缀点成线" class="headerlink" title="力扣1232 缀点成线"></a>力扣1232 缀点成线</h2><p>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</p><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。</p><p>示例 1：</p><p>输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]<br>输出：true<br><img src="https://img-blog.csdnimg.cn/20210117172241259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> deltaX = coordinates[<span class="number">0</span>][<span class="number">0</span>], deltaY = coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = coordinates.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            coordinates[i][<span class="number">0</span>] -= deltaX;</span><br><span class="line">            coordinates[i][<span class="number">1</span>] -= deltaY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = coordinates[<span class="number">1</span>][<span class="number">1</span>], B = -coordinates[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = coordinates[i][<span class="number">0</span>], y = coordinates[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (A * x + B * y != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="64x的平方根"><a href="#64x的平方根" class="headerlink" title="64x的平方根"></a>64x的平方根</h2><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2<br>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用内置函数：注意从<span class="keyword">double</span>转为<span class="keyword">int</span>的操作格式 </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.sqrt(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：二分查找<br>由于 xx 平方根的整数部分 \textit{ans}ans 是满足 k^2 \leq xk<br>2<br> ≤x 的最大 kk 值，因此我们可以对 kk 进行二分查找，从而得到答案。</p><p>二分查找的下界为 00，上界可以粗略地设定为 xx。在二分查找的每一步中，我们只需要比较中间元素 \textit{mid}mid 的平方与 xx 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 \textit{ans}ans 后，也就不需要再去尝试 \textit{ans} + 1ans+1 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">思路，二分查找的下界<span class="number">0</span> 上界x，每一步比较中间元素的平方和x的大小</span><br><span class="line">根据结果调整上界和下界的范围。</span><br><span class="line">注意  <span class="keyword">long</span>的使用 mid不是最终结果是要令l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣83删除排序链表中的重复元素"><a href="#力扣83删除排序链表中的重复元素" class="headerlink" title="力扣83删除排序链表中的重复元素"></a>力扣83删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; current.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.next.val == current.val) &#123;</span><br><span class="line">                current.next = current.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*</p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88 合并两个有序数组"></a>88 合并两个有序数组</h2><p>*<br>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小等于 m + n）来保存 nums2 中的元素。</p><p>示例 1：</p><p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]<br>示例 2：</p><p>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]</p><p><img src="https://img-blog.csdnimg.cn/20210113122118126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">复杂度 O(m+n)log(m+n)</span><br><span class="line">思路  先合并两个数组，nums2是原数组，<span class="number">0</span>：表示从<span class="number">0</span>索引开始，nums1：目标数组  m：目标数组开始插入的位置  n：n是数组<span class="number">2</span>的长度</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, m, n);</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">解题方案</span><br><span class="line">思路</span><br><span class="line"><span class="number">1</span>、标签：从后向前数组遍历</span><br><span class="line"><span class="number">2</span>、因为 nums1 的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去</span><br><span class="line"><span class="number">3</span>、设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充</span><br><span class="line"><span class="number">4</span>、当 len1&lt;<span class="number">0</span> 时遍历结束，此时 nums2 中海油数据未拷贝完全，将其直接拷贝到 nums1 的前面，最后得到结果数组</span><br><span class="line">时间复杂度：O(m+n)O(m+n)</span><br><span class="line"></span><br><span class="line">代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len1 &gt;= <span class="number">0</span> &amp;&amp; len2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码</span></span><br><span class="line">            nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1</span></span><br><span class="line">        System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, len2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">思路：三个指针，分别指向数组<span class="number">1</span>：p1 数组2p2 数组<span class="number">1</span>扩展从后到前的指针p</span><br><span class="line">从后向前遍历，p1&gt;p2，将p1索引处的值放入最后</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// two get pointers for nums1 and nums2</span></span><br><span class="line">    <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// set pointer for nums1</span></span><br><span class="line">    <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while there are still elements to compare</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>))</span><br><span class="line">      <span class="comment">// compare two elements from nums1 and nums2 </span></span><br><span class="line">      <span class="comment">// and add the largest one in nums1 </span></span><br><span class="line">      nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add missing elements from nums2</span></span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210113134422873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4、寻找两个正序数组的中位数"><a href="#4、寻找两个正序数组的中位数" class="headerlink" title="4、寻找两个正序数组的中位数"></a>4、寻找两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p><p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p><p>示例 1：</p><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：</p><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p><p>示例 3：</p><p>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000<br>示例 4：</p><p>输入：nums1 = [], nums2 = [1]<br>输出：1.00000<br>示例 5：</p><p>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p><p>提示：</p><p>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>-106 &lt;= nums1[i], nums2[i] &lt;= 106</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> len = m+n;</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>;  <span class="comment">//left用于存储上一个结果，也就是当前位置的前一个结果（中位数的前一个）</span></span><br><span class="line">        <span class="keyword">int</span> right = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> aStart=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bStart=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            left = right;</span><br><span class="line">            <span class="keyword">if</span>(aStart&lt;m&amp;&amp;(bStart&gt;=n||nums1[aStart]&lt;nums2[bStart]))&#123;</span><br><span class="line">                right = nums1[aStart++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = nums2[bStart++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (left+right)/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣38外观数列"><a href="#力扣38外观数列" class="headerlink" title="力扣38外观数列"></a>力扣38外观数列</h2><p>给定一个正整数 n ，输出外观数列的第 n 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><p>countAndSay(1) = “1”<br>countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。<br>前五项如下：</p><ol><li><pre><code>1</code></pre></li><li><pre><code>11</code></pre></li><li><pre><code>21</code></pre></li><li><pre><code>1211</code></pre></li><li><pre><code>111221</code></pre>第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”<br>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</li></ol><p>例如，数字字符串 “3322251” 的描述如下图：</p><p>示例 1：</p><p>输入：n = 1<br>输出：”1”<br>解释：这是一个基本样例。<br>示例 2：</p><p>输入：n = 4<br>输出：”1211”<br>解释：<br>countAndSay(1) = “1”<br>countAndSay(2) = 读 “1” = 一 个 1 = “11”<br>countAndSay(3) = 读 “11” = 二 个 1 = “21”<br>countAndSay(4) = 读 “21” = 一 个 2 + 一 个 1 = “12” + “11” = “1211”</p><p>提示：</p><p>1 &lt;= n &lt;= 30</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">思路：下一个字符串是描述的上一个字符串</span><br><span class="line">所以需要建立一个类来做这件事</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] dp = <span class="keyword">new</span> String[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = describe(dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">describe</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> len = pre.length();</span><br><span class="line">        <span class="keyword">int</span> num = pre.charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.charAt(i) == pre.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.append(count);</span><br><span class="line">                ans.append(num);</span><br><span class="line">                num = pre.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == len - <span class="number">1</span>) &#123;</span><br><span class="line">                ans.append(count);</span><br><span class="line">                ans.append(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a>461. 汉明距离</h2><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p><p>注意：<br>0 ≤ x, y &lt; 231.</p><p>示例:</p><p>输入: x = 1, y = 4</p><p>输出: 2</p><p>解释:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑</p><p>上面的箭头指出了对应二进制位不同的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = x^y;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">思路：深度优先搜素</span><br><span class="line">遍历每一个节点的最大值，记录该节点左节点的长度和右节点长度的和，利用全局变量保留其中的最大值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</span><br><span class="line">我们定义一个递归函数 depth(node) 计算 d_&#123;\textit&#123;node&#125;&#125;d </span><br><span class="line">node</span><br><span class="line"></span><br><span class="line">  ，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 LL 和 RR ，则该节点为根的子树的深度即为</span><br><span class="line"></span><br><span class="line">max(L,R)+<span class="number">1</span></span><br><span class="line">max(L,R)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">该节点的 d_&#123;\textit&#123;node&#125;&#125;d </span><br><span class="line">node</span><br><span class="line"></span><br><span class="line">  值为</span><br><span class="line"></span><br><span class="line">L+R+<span class="number">1</span></span><br><span class="line">L+R+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">递归搜索每个节点并设一个全局变量 ansans 记录点node为起点的路径经过节点数的最大值为dnode，最后返回 ans-<span class="number">1</span> 即为树的直径。</span><br><span class="line">![在这里插入图片描述](https:<span class="comment">//img-blog.csdnimg.cn/20210110222533507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)</span></span><br><span class="line"></span><br><span class="line">而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> L = depth(node.left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> R = depth(node.right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = Math.max(ans, L+R+<span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxd=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> maxd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Left = depth(node.left);</span><br><span class="line">        <span class="keyword">int</span> Right = depth(node.right);</span><br><span class="line">        maxd=Math.max(Left+Right,maxd);<span class="comment">//将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(Left,Right)+<span class="number">1</span>;<span class="comment">//返回节点深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / <br>       4   5<br>      / \   \<br>     5   4   7<br>注意: 合并必须从两个树的根节点开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> t2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> t1;</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode merged = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">                merged.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">                merged.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣226：翻转二叉树"><a href="#力扣226：翻转二叉树" class="headerlink" title="力扣226：翻转二叉树"></a>力扣226：翻转二叉树</h2><p>方法一：递归<br>思路与算法</p><p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子结点先开始翻转。如果当前遍历到的节点 \textit{root}root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 \textit{root}root 为根节点的整棵子树的翻转。</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">其实就是交换一下左右节点，然后再递归的交换左节点，右节点</span><br><span class="line">根据动画图我们可以总结出递归的两个条件如下：</span><br><span class="line"></span><br><span class="line">终止条件：当前节点为 <span class="keyword">null</span> 时返回</span><br><span class="line">交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点</span><br><span class="line">时间复杂度：每个元素都必须访问一次，所以是 O(n)O(n)</span><br><span class="line">空间复杂度：最坏的情况下，需要存放 O(h)O(h) 个函数调用(h是树的高度)，所以是 O(h)O(h)</span><br><span class="line">代码实现如下：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//递归函数的终止条件，节点为空时返回</span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面三句是将当前节点的左右子树交换</span></span><br><span class="line">TreeNode tmp = root.right;</span><br><span class="line">root.right = root.left;</span><br><span class="line">root.left = tmp;</span><br><span class="line"><span class="comment">//递归交换当前节点的 左子树</span></span><br><span class="line">invertTree(root.left);</span><br><span class="line"><span class="comment">//递归交换当前节点的 右子树</span></span><br><span class="line">invertTree(root.right);</span><br><span class="line"><span class="comment">//函数返回时就表示当前这个节点，以及它的左右子树</span></span><br><span class="line"><span class="comment">//都已经交换完了</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210106203544415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210106203856503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70"></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 2：</p><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">标签：动态规划</span><br><span class="line"><span class="number">1</span>、动态规划方程：dp[n] = MAX( dp[n-<span class="number">1</span>], dp[n-<span class="number">2</span>] + num )</span><br><span class="line"><span class="number">2</span>、由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-<span class="number">1</span> 房屋可盗窃的最大值，要么就是 n-<span class="number">2</span> 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值</span><br><span class="line"><span class="number">3</span>、举例来说：<span class="number">1</span> 号房间可盗窃最大值为 <span class="number">33</span> 即为 dp[<span class="number">1</span>]=<span class="number">3</span>，<span class="number">2</span> 号房间可盗窃最大值为 <span class="number">44</span> 即为 dp[<span class="number">2</span>]=<span class="number">4</span>，<span class="number">3</span> 号房间自身的值为 <span class="number">22</span> 即为 num=<span class="number">2</span>，那么 dp[<span class="number">3</span>] = MAX( dp[<span class="number">2</span>], dp[<span class="number">1</span>] + num ) = MAX(<span class="number">4</span>, <span class="number">3</span>+<span class="number">2</span>) = <span class="number">5</span>，<span class="number">3</span> 号房间可盗窃最大值为 <span class="number">55</span></span><br><span class="line"><span class="number">4</span>、时间复杂度：O(n)O(n)，nn 为数组长度</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣169-多数元素"><a href="#力扣169-多数元素" class="headerlink" title="力扣169 多数元素"></a>力扣169 多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1：</p><p>输入：[3,2,3]<br>输出：3<br>示例 2：</p><p>输入：[2,2,1,1,1,2,2]<br>输出：2</p><p>进阶：</p><p>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">法<span class="number">1</span>：HashMap法</span><br><span class="line">思路，建立一个存储元素个数和元素名称的HashMap  HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="number">1</span>、遍历数组，将未出现的元素送入HashMap，并记录个数为<span class="number">1</span></span><br><span class="line"><span class="number">2</span>、将出现过的元素进行加一，统计个数</span><br><span class="line"><span class="number">3</span>、判断该元素出现次数是否已经大于<span class="number">1</span>/<span class="number">2</span>，是则返回即可</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i],map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i])&gt;Math.floor(nums.length/<span class="number">2.0</span>))&#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">法<span class="number">2</span>：摩尔投票，<span class="number">169</span></span><br><span class="line">一次遍历；</span><br><span class="line">记录当前值和次数；</span><br><span class="line">如果遍历值与当前值相同，times自增，不同，times自减；</span><br><span class="line">通过增减抵消的方式，最终达到剩下的数字是结果的效果，时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">理解：多数元素的特点是，他大于二分之一所以他可以和其他元素进行抵消，剩下的元素一定是多数元素，所以  与当前值相同则自增，不同则自减</span><br><span class="line">只需要一个单元来存储元素名（元素名初始为第一个元素，当times=0s时更新到下一个元素，不断更新）</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cand_num = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cand_num == nums[i])</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">                cand_num = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣155-最小栈"><a href="#力扣155-最小栈" class="headerlink" title="力扣155 最小栈"></a>力扣155 最小栈</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p><p>示例:</p><p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p>输出：<br>[null,null,null,null,-3,null,0,-2]</p><p>解释：<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.<br>提示：</p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</span><br><span class="line"></span><br><span class="line">当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</span><br><span class="line"></span><br><span class="line">当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</span><br><span class="line"></span><br><span class="line">在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</span><br><span class="line"></span><br><span class="line">每次压栈是minStack和xStack都要压栈，xStack压栈元素是当前数据，minStack压入当前数据和minStack比较的最小值</span><br><span class="line">每次出栈都是minStack和xStack都出栈</span><br><span class="line">每次top只需返回xStack的栈顶元素，不需要出栈</span><br><span class="line">getMin返回minStack的栈顶元素</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        xStack.push(x);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">每次压栈比较minStack栈顶元素和当前元素的大小（当前值是不是最小值）如果是，那么压栈到minStack,也要压到数据栈</span><br><span class="line">如果不是，压栈只需要压到数据栈，minStack不需要更改</span><br><span class="line">出栈时考虑一下出栈元素和minStack元素是否相等，相等则minStack也出栈，否则，仅数据栈出栈</span><br><span class="line">top返回数据栈栈顶元素</span><br><span class="line">getMin返回minStack栈顶元素</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line">    <span class="comment">// 辅助栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 思路 2：辅助栈和数据栈不同步</span></span><br><span class="line">    <span class="comment">// 关键 1：辅助栈的元素空的时候，必须放入新进来的数</span></span><br><span class="line">    <span class="comment">// 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）</span></span><br><span class="line">    <span class="comment">// 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即&quot;出栈保持同步&quot;就可以了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 辅助栈在必要的时候才增加</span></span><br><span class="line">        data.add(x);</span><br><span class="line">        <span class="comment">// 关键 1 和 关键 2</span></span><br><span class="line">        <span class="keyword">if</span> (helper.isEmpty() || helper.peek() &gt;= x) &#123;</span><br><span class="line">            helper.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关键 3：data 一定得 pop()</span></span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，因此下面的比较可以使用 &quot;==&quot; 运算符</span></span><br><span class="line">            <span class="comment">// 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html</span></span><br><span class="line">            <span class="comment">// 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方法</span></span><br><span class="line">            <span class="keyword">int</span> top = data.pop();</span><br><span class="line">            <span class="keyword">if</span>(top == helper.peek())&#123;</span><br><span class="line">                helper.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> data.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈中元素为空，此操作非法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!helper.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> helper.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈中元素为空，此操作非法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>法3：不使用辅助栈</p><p>栈中元素除了保存当前值之外，额外保存当前最小值<br>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Node&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将元素值 x 和 当前最小值 同时入栈。</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            stack.push(<span class="keyword">new</span> Node(x, x));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(<span class="keyword">new</span> Node(x, Math.min(x, stack.peek().min)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回栈顶元素中的元素值。</span></span><br><span class="line">        <span class="keyword">return</span> stack.peek().val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回栈顶元素的最小值</span></span><br><span class="line">        <span class="keyword">return</span> stack.peek().min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.min = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">方法一：哈希表</span><br><span class="line">思路及算法</span><br><span class="line"></span><br><span class="line">最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</span><br><span class="line"></span><br><span class="line">具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; seen = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!seen.add(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：快慢指针</span><br><span class="line">思路及算法</span><br><span class="line"></span><br><span class="line">本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</span><br><span class="line"></span><br><span class="line">假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</span><br><span class="line"></span><br><span class="line">我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line">初始化：讨论链表为空或者只有一个元素的情况</span><br><span class="line">直接<span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">快指针：从head.next出发，每次跳两步  head.next.next</span><br><span class="line">满指针：从head出发，每次跳一步 head.next</span><br><span class="line"></span><br><span class="line">如果满足他们是环形链表</span><br><span class="line">那么会重叠</span><br><span class="line">如果不满足环形链表，那么快指针会率先到达<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210303155727623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210303155810818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">概括一下：</span><br><span class="line"></span><br><span class="line">根据：</span><br><span class="line"></span><br><span class="line">f=2s （快指针每次<span class="number">2</span>步，路程刚好<span class="number">2</span>倍）</span><br><span class="line"></span><br><span class="line">f = s + nb (相遇时，刚好多走了n圈）</span><br><span class="line"></span><br><span class="line">推出：s = nb</span><br><span class="line"></span><br><span class="line">从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。</span><br><span class="line"></span><br><span class="line">如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>136 只出现一次的数字<br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">标签：位运算</span><br><span class="line"><span class="number">1</span>、本题根据题意，线性时间复杂度 O(n)O(n)，很容易想到使用 Hash 映射来进行计算，遍历一次后结束得到结果，但是在空间复杂度上会达到 O(n)O(n)，需要使用较多的额外空间</span><br><span class="line"><span class="number">2</span>、既满足时间复杂度又满足空间复杂度，就要提到位运算中的异或运算 XOR，主要因为异或运算有以下几个特点：</span><br><span class="line">一个数和 <span class="number">0</span> 做 XOR 运算等于本身：a⊕<span class="number">0</span> = a</span><br><span class="line">一个数和其本身做 XOR 运算等于 <span class="number">0</span>：a⊕a = <span class="number">0</span></span><br><span class="line">XOR 运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = <span class="number">0</span>⊕b = b</span><br><span class="line"><span class="number">3</span>、故而在以上的基础条件上，将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字</span><br><span class="line">时间复杂度：O(n)O(n)，空间复杂度：O(<span class="number">1</span>)O(<span class="number">1</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            ans ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣121：买卖股票的最佳时机"><a href="#力扣121：买卖股票的最佳时机" class="headerlink" title="力扣121：买卖股票的最佳时机"></a>力扣121：买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>解决方案<br>我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。</p><p>形式上，对于每组 ii 和 jj（其中 j &gt; ij&gt;i）我们需要找出 \max(prices[j] - prices[i])max(prices[j]−prices[i])。</p><p>方法一：暴力法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">                <span class="keyword">if</span> (profit &gt; maxprofit) &#123;</span><br><span class="line">                    maxprofit = profit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法</p><p>假设给定的数组为：[7, 1, 5, 3, 6, 4]</p><p>如果我们在图表上绘制给定数组中的数字，我们将会得到：</p><p><img src="https://img-blog.csdnimg.cn/20210106151552795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？</p><p>显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p><p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">答案<span class="number">1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">答案<span class="number">2</span>：</span><br><span class="line">个人理解：</span><br><span class="line"><span class="number">1</span>、prices长度为<span class="number">0</span>  return0</span><br><span class="line"><span class="number">2</span>、prices长度为<span class="number">1</span>无法进入循环  result=初始值<span class="number">0</span></span><br><span class="line"><span class="number">3</span>、初始最小买入点：prices[<span class="number">0</span>]</span><br><span class="line"><span class="number">4</span>、遍历数组：</span><br><span class="line">将当前索引的值作为抛售点的值是否比result大，是的话，这个作为result</span><br><span class="line">当前抛售点作为买入点时是否比min小，是的话，这个作为新的买入点</span><br><span class="line"><span class="number">5</span>、返回result</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            result=Math.max(prices[i]-min,result);</span><br><span class="line">            min = Math.min(prices[i],min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣121：买卖股票的最佳时机-1"><a href="#力扣121：买卖股票的最佳时机-1" class="headerlink" title="力扣121：买卖股票的最佳时机"></a>力扣121：买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>解决方案<br>我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。</p><p>形式上，对于每组 ii 和 jj（其中 j &gt; ij&gt;i）我们需要找出 \max(prices[j] - prices[i])max(prices[j]−prices[i])。</p><p>方法一：暴力法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">                <span class="keyword">if</span> (profit &gt; maxprofit) &#123;</span><br><span class="line">                    maxprofit = profit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法</p><p>假设给定的数组为：[7, 1, 5, 3, 6, 4]</p><p>如果我们在图表上绘制给定数组中的数字，我们将会得到：</p><p><img src="https://img-blog.csdnimg.cn/20210106151552795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？</p><p>显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p><p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">答案<span class="number">1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">答案<span class="number">2</span>：</span><br><span class="line">个人理解：</span><br><span class="line"><span class="number">1</span>、prices长度为<span class="number">0</span>  return0</span><br><span class="line"><span class="number">2</span>、prices长度为<span class="number">1</span>无法进入循环  result=初始值<span class="number">0</span></span><br><span class="line"><span class="number">3</span>、初始最小买入点：prices[<span class="number">0</span>]</span><br><span class="line"><span class="number">4</span>、遍历数组：</span><br><span class="line">将当前索引的值作为抛售点的值是否比result大，是的话，这个作为result</span><br><span class="line">当前抛售点作为买入点时是否比min小，是的话，这个作为新的买入点</span><br><span class="line"><span class="number">5</span>、返回result</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            result=Math.max(prices[i]-min,result);</span><br><span class="line">            min = Math.min(prices[i],min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣104：二叉树的最大深度"><a href="#力扣104：二叉树的最大深度" class="headerlink" title="力扣104：二叉树的最大深度"></a>力扣104：二叉树的最大深度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">解题思路</span><br><span class="line"><span class="number">1</span>、标签：DFS</span><br><span class="line"><span class="number">2</span>、找出终止条件：当前节点为空</span><br><span class="line"><span class="number">3</span>、找出返回值：节点为空时说明高度为 <span class="number">0</span>，所以返回 <span class="number">0</span>；节点不为空时则分别求左右子树的高度的最大值，同时加<span class="number">1</span>表示当前节点的高度，返回该数值</span><br><span class="line"><span class="number">4</span>、某层的执行过程：在返回值部分基本已经描述清楚</span><br><span class="line"><span class="number">5</span>、时间复杂度：O(n)O(n)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣226：翻转二叉树-1"><a href="#力扣226：翻转二叉树-1" class="headerlink" title="力扣226：翻转二叉树"></a>力扣226：翻转二叉树</h2><p>方法一：递归<br>思路与算法</p><p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子结点先开始翻转。如果当前遍历到的节点 \textit{root}root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 \textit{root}root 为根节点的整棵子树的翻转。</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">其实就是交换一下左右节点，然后再递归的交换左节点，右节点</span><br><span class="line">根据动画图我们可以总结出递归的两个条件如下：</span><br><span class="line"></span><br><span class="line">终止条件：当前节点为 <span class="keyword">null</span> 时返回</span><br><span class="line">交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点</span><br><span class="line">时间复杂度：每个元素都必须访问一次，所以是 O(n)O(n)</span><br><span class="line">空间复杂度：最坏的情况下，需要存放 O(h)O(h) 个函数调用(h是树的高度)，所以是 O(h)O(h)</span><br><span class="line">代码实现如下：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//递归函数的终止条件，节点为空时返回</span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面三句是将当前节点的左右子树交换</span></span><br><span class="line">TreeNode tmp = root.right;</span><br><span class="line">root.right = root.left;</span><br><span class="line">root.left = tmp;</span><br><span class="line"><span class="comment">//递归交换当前节点的 左子树</span></span><br><span class="line">invertTree(root.left);</span><br><span class="line"><span class="comment">//递归交换当前节点的 右子树</span></span><br><span class="line">invertTree(root.right);</span><br><span class="line"><span class="comment">//函数返回时就表示当前这个节点，以及它的左右子树</span></span><br><span class="line"><span class="comment">//都已经交换完了</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣234：回文链表"><a href="#力扣234：回文链表" class="headerlink" title="力扣234：回文链表"></a>力扣234：回文链表</h2><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>，使用栈解决</span><br><span class="line">我们知道栈是先进后出的一种数据结构，这里还可以使用栈先把链表的节点全部存放到栈中，然后再一个个出栈，这样就相当于链表从后往前访问了，通过这种方式也能解决，看下代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode temp = head;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">//把链表节点的值存放到栈中</span></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(temp.val);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后再出栈</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val != stack.pop()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">这里相当于链表从前往后全部都比较了一遍，其实我们只需要拿链表的后半部分和前半部分比较即可，没必要全部比较，所以这里可以优化一下</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    ListNode temp = head;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">//链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把链表节点的值存放到栈中</span></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(temp.val);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//len长度除以2</span></span><br><span class="line">    len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//然后再出栈</span></span><br><span class="line">    <span class="keyword">while</span> (len-- &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val != stack.pop())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣448：找到所有数组中消失的数字"><a href="#力扣448：找到所有数组中消失的数字" class="headerlink" title="力扣448：找到所有数组中消失的数字"></a>力扣448：找到所有数组中消失的数字</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:</p><p>输入:<br>[4,3,2,7,8,2,3,1]</p><p>输出:<br>[5,6]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Hash table for keeping track of the numbers in the array</span></span><br><span class="line">        <span class="comment">// Note that we can also use a set here since we are not </span></span><br><span class="line">        <span class="comment">// really concerned with the frequency of numbers.</span></span><br><span class="line">        HashMap&lt;Integer, Boolean&gt; hashTable = <span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Add each of the numbers to the hash table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            hashTable.put(nums[i], <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Response array that would contain the missing numbers</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Iterate over the numbers from 1 to N and add all those</span></span><br><span class="line">        <span class="comment">// that don&#x27;t appear in the hash table. </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hashTable.containsKey(i)) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N)<br>空间复杂度：O(N)</p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">思路</span><br><span class="line"><span class="number">1</span>、这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来</span><br><span class="line"><span class="number">2</span>、动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans</span><br><span class="line"><span class="number">3</span>、如果 sum &gt; <span class="number">0</span>，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字</span><br><span class="line"><span class="number">4</span>、如果 sum &lt;= <span class="number">0</span>，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字</span><br><span class="line"><span class="number">5</span>、每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果</span><br><span class="line"><span class="number">6</span>、时间复杂度：O(n)O(n)</span><br><span class="line">其实这道题可以这么想： </span><br><span class="line"><span class="number">1</span>、假如全是负数，那就是找最大值即可，因为负数肯定越加越大。 </span><br><span class="line"><span class="number">2</span>、如果有正数，则肯定从正数开始计算和，不然前面有负值，和肯定变小了，所以从正数开始。 </span><br><span class="line"><span class="number">3</span>、当和小于零时，这个区间就告一段落了，然后从下一个正数重新开始计算(也就是又回到 <span class="number">2</span> 了)。而 dp 也就体现在这个地方。</span><br><span class="line"></span><br><span class="line">个人理解：</span><br><span class="line"><span class="number">1</span>、创建变量ans存储上一个子数组的和，sum存储当前子数组的和</span><br><span class="line"><span class="number">2</span>、</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">注释：<span class="keyword">for</span>(<span class="keyword">int</span> num: nums)解释</span><br><span class="line">首先，nums是一个数组，里面放的是<span class="keyword">int</span>类型的数据，然后定义了一个<span class="keyword">int</span>类型的变量num，每循环一次，就从nums数组中取出一个数据来打印。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ：表示你要遍历的集合的类型</span><br><span class="line"></span><br><span class="line">nums：表示你要遍历的集合的名</span><br><span class="line"></span><br><span class="line">num：表示你每遍历集合中一个元素 便存储到该变量中，</span><br><span class="line"></span><br><span class="line">然后在foreach语句的&#123;&#125;使用num变量；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>]; <span class="comment">//为什么是n+2:n+1情况下可以理解（0到n有n+1个台阶）  n+2是因为输入n=1时候，我们定义的dp[2]就失效了，所以要定义n+2个元素的dp数组。</span></span><br><span class="line">        <span class="comment">//该数组每个元素的指针对应的是台阶数,元素的值存放的是台阶数对应的方法数</span></span><br><span class="line">        <span class="comment">//dp[0] = 0; //不管怎样,数组下标指针肯定是从0开始的,所以要考虑0.有0个台阶,不需要爬,所以没有方法数(但从斐波那契角度,dp[0]=1)</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//1阶台阶,只有一种方式(1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2阶台阶,有两种方式(1+1, 2), 因为题目设定n是正整数,所以n最小是1,此时如果定义dp的长度是int[n + 1],则length=2</span></span><br><span class="line">        <span class="comment">//而dp[2]实际对应的是第三个元素,超出length了,所以定义new int[n + 2]更合理</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第三个台阶开始遍历,第三个台阶,是第二个台阶的方法和第一个台阶的方法之和</span></span><br><span class="line">        <span class="comment">//第四个台阶,是第三个台阶和第二个台阶方法之和,依此论推....</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">//要遍历到第n个台阶,所以指针其实是从0到n,所以dp数组数量比n多1</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]; <span class="comment">//最后到第n个台阶,得到结果后正好遍历完</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105224537930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="链表求交点"><a href="#链表求交点" class="headerlink" title="链表求交点"></a>链表求交点</h2><p>[<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-fa-lang-man-xiang-yu-by-ml-zimingm/]">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-fa-lang-man-xiang-yu-by-ml-zimingm/]</a><br>看图   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">思路：类似于求最小公倍数的感觉。</span><br><span class="line">我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</span><br><span class="line"></span><br><span class="line">这样，当它们相遇时，所指向的结点就是第一个公共结点。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode PA = headA;</span><br><span class="line">        ListNode PB = headB;</span><br><span class="line">        <span class="keyword">while</span> (PA != PB) &#123;</span><br><span class="line">            PA = PA == <span class="keyword">null</span> ? headB : PA.next;</span><br><span class="line">            PB = PB == <span class="keyword">null</span> ? headA : PB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> PA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode l1 = headA;</span><br><span class="line">        ListNode l2 = headB;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="keyword">null</span>||headB==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1!=l2)&#123;</span><br><span class="line">            <span class="comment">//l1=l1.next!=null?l1.next:headA;这样写是错的，会超时，只需检查l1和l2是否相等是否为空即可，这样写会导致在没有交点时，一直编译，所以报错，即l1.next永远会指向head而不会只想null使其停止</span></span><br><span class="line">            <span class="comment">//l2=l2.next!=null?l2.next:headB;</span></span><br><span class="line">            l1=l1!=<span class="keyword">null</span>?l1.next:headA;</span><br><span class="line">            l2=l2!=<span class="keyword">null</span>?l2.next:headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br></pre></td></tr></table></figure><p>力扣206反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<img src="https://img-blog.csdnimg.cn/20210105223928194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">思路</span><br><span class="line">临时节点next指向原head的next</span><br><span class="line">head.next指向new_head</span><br><span class="line">new_head指向head</span><br><span class="line">head更新到临时节点</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode new_head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = new_head;</span><br><span class="line">            new_head = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Definition for singly-linked list.</li><li>public class ListNode {</li><li><pre><code>int val;</code></pre></li><li><pre><code>ListNode next;</code></pre></li><li><pre><code>ListNode(int x) &#123; val = x; &#125;</code></pre></li><li>}</li><li>/</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">思路 用栈   先将链表送入栈中    再将栈中元素依次取出，每一次新开发一个存取单元，让node指向他即可</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = stack.pop();</span><br><span class="line">        ListNode dummy = node;</span><br><span class="line">        <span class="comment">//栈中的结点全部出栈，然后重新连成一个新的链表</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ListNode tempNode = stack.pop();</span><br><span class="line">            node.next = tempNode;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个结点就是反转前的头结点，一定要让他的next</span></span><br><span class="line">        <span class="comment">//等于空，否则会构成环</span></span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>力扣206反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<img src="https://img-blog.csdnimg.cn/20210105223928194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">思路</span><br><span class="line">临时节点next指向原head的next</span><br><span class="line">head.next指向new_head</span><br><span class="line">new_head指向head</span><br><span class="line">head更新到临时节点</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode new_head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = new_head;</span><br><span class="line">            new_head = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Definition for singly-linked list.</li><li>public class ListNode {</li><li><pre><code>int val;</code></pre></li><li><pre><code>ListNode next;</code></pre></li><li><pre><code>ListNode(int x) &#123; val = x; &#125;</code></pre></li><li>}</li><li>/</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">思路 用栈   先将链表送入栈中    再将栈中元素依次取出，每一次新开发一个存取单元，让node指向他即可</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = stack.pop();</span><br><span class="line">        ListNode dummy = node;</span><br><span class="line">        <span class="comment">//栈中的结点全部出栈，然后重新连成一个新的链表</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ListNode tempNode = stack.pop();</span><br><span class="line">            node.next = tempNode;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个结点就是反转前的头结点，一定要让他的next</span></span><br><span class="line">        <span class="comment">//等于空，否则会构成环</span></span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣28实现strStr"><a href="#力扣28实现strStr" class="headerlink" title="力扣28实现strStr()"></a>力扣28实现strStr()</h2><p>概述<br>这道题是要在 haystack 字符串中找到 needle 字符串。下面会给出的三种解法，这三种解法都基于滑动窗口。</p><p>子串逐一比较的解法最简单，将长度为 L 的滑动窗口沿着 haystack 字符串逐步移动，并将窗口内的子串与 needle 字符串相比较，时间复杂度为 O((N - L)L)O((N−L)L)</p><p>显示上面这个方法是可以优化的。双指针方法虽然也是线性时间复杂度，不过它可以避免比较所有的子串，因此最优情况下的时间复杂度为 O(N)O(N)，但最坏情况下的时间复杂度依然为 O((N - L)L)O((N−L)L)。</p><p>有 O(N)O(N) 复杂度的解法嘛？答案是有的，有两种方法可以实现：</p><p>Rabin-Karp，通过哈希算法实现常数时间窗口内字符串比较。</p><p>比特位操作，通过比特掩码来实现常数时间窗口内字符串比较。</p><p>方法一：子串逐一比较 - 线性时间复杂度<br>最直接的方法 - 沿着字符换逐步移动滑动窗口，将窗口内的子串与 needle 字符串比较。</p><p><img src="https://img-blog.csdnimg.cn/20210105214852920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">重点是substring函数的使用，</span><br><span class="line"><span class="comment">//haystack.substring(start, start + L).equals(needle)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = needle.length(), n = haystack.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n - L + <span class="number">1</span>; ++start) &#123;</span><br><span class="line">      <span class="keyword">if</span> (haystack.substring(start, start + L).equals(needle)) &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣28实现strStr-1"><a href="#力扣28实现strStr-1" class="headerlink" title="力扣28实现strStr()"></a>力扣28实现strStr()</h2><p>概述<br>这道题是要在 haystack 字符串中找到 needle 字符串。下面会给出的三种解法，这三种解法都基于滑动窗口。</p><p>子串逐一比较的解法最简单，将长度为 L 的滑动窗口沿着 haystack 字符串逐步移动，并将窗口内的子串与 needle 字符串相比较，时间复杂度为 O((N - L)L)O((N−L)L)</p><p>显示上面这个方法是可以优化的。双指针方法虽然也是线性时间复杂度，不过它可以避免比较所有的子串，因此最优情况下的时间复杂度为 O(N)O(N)，但最坏情况下的时间复杂度依然为 O((N - L)L)O((N−L)L)。</p><p>有 O(N)O(N) 复杂度的解法嘛？答案是有的，有两种方法可以实现：</p><p>Rabin-Karp，通过哈希算法实现常数时间窗口内字符串比较。</p><p>比特位操作，通过比特掩码来实现常数时间窗口内字符串比较。</p><p>方法一：子串逐一比较 - 线性时间复杂度<br>最直接的方法 - 沿着字符换逐步移动滑动窗口，将窗口内的子串与 needle 字符串比较。</p><p><img src="https://img-blog.csdnimg.cn/20210105214852920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">重点是substring函数的使用，</span><br><span class="line"><span class="comment">//haystack.substring(start, start + L).equals(needle)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = needle.length(), n = haystack.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n - L + <span class="number">1</span>; ++start) &#123;</span><br><span class="line">      <span class="keyword">if</span> (haystack.substring(start, start + L).equals(needle)) &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣27移除元素"><a href="#力扣27移除元素" class="headerlink" title="力扣27移除元素"></a>力扣27移除元素</h2><p>和力扣26类似  双指针，很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(<span class="number">1</span>) 额外空间并 原地 修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">给定 nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">概要</span><br><span class="line">这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。</span><br><span class="line"></span><br><span class="line">提示</span><br><span class="line">尝试双指针法。</span><br><span class="line">你是否使用“元素顺序可以更改”这一属性？</span><br><span class="line">当要删除的元素很少时会发生什么？</span><br><span class="line">解决方案</span><br><span class="line">方法一：双指针</span><br><span class="line">思路</span><br><span class="line"></span><br><span class="line">既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(<span class="number">1</span>)O(<span class="number">1</span>) 的额外空间来处理它。如何解决？我们可以保留两个指针 ii 和 jj，其中 ii 是慢指针，jj 是快指针。</span><br><span class="line"></span><br><span class="line">算法</span><br><span class="line"></span><br><span class="line">当 nums[j]nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] \neq valnums[j] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> =val，我们就复制 nums[j]nums[j] 到 nums[i]nums[i] 并同时递增两个索引。重复这一过程，直到 jj 到达数组的末尾，该数组的新长度为 ii。</span><br><span class="line"></span><br><span class="line">该解法与 删除排序数组中的重复项 的解法十分相似。</span><br><span class="line"></span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n)O(n)，</span><br><span class="line">假设数组总共有 nn 个元素，ii 和 jj 至少遍历 2n2n 步。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(<span class="number">1</span>)O(<span class="number">1</span>)。</span><br><span class="line"></span><br><span class="line">方法二：双指针 —— 当要删除的元素很少时</span><br><span class="line">思路</span><br><span class="line"></span><br><span class="line">现在考虑数组包含很少的要删除的元素的情况。例如，num=[<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">4</span>]，Val=4num=[<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">4</span>]，Val=<span class="number">4</span>。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[<span class="number">4</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>]，Val=4num=[<span class="number">4</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>]，Val=<span class="number">4</span>。似乎没有必要将 [<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>][<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。</span><br><span class="line"></span><br><span class="line">算法</span><br><span class="line"></span><br><span class="line">当我们遇到 nums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。</span><br><span class="line"></span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[n - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// reduce array size by one</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n)O(n)，ii 和 nn 最多遍历 nn 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(<span class="number">1</span>)O(<span class="number">1</span>)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣27移除元素-1"><a href="#力扣27移除元素-1" class="headerlink" title="力扣27移除元素"></a>力扣27移除元素</h2><p>和力扣26类似  双指针，很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(<span class="number">1</span>) 额外空间并 原地 修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">给定 nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">概要</span><br><span class="line">这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。</span><br><span class="line"></span><br><span class="line">提示</span><br><span class="line">尝试双指针法。</span><br><span class="line">你是否使用“元素顺序可以更改”这一属性？</span><br><span class="line">当要删除的元素很少时会发生什么？</span><br><span class="line">解决方案</span><br><span class="line">方法一：双指针</span><br><span class="line">思路</span><br><span class="line"></span><br><span class="line">既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(<span class="number">1</span>)O(<span class="number">1</span>) 的额外空间来处理它。如何解决？我们可以保留两个指针 ii 和 jj，其中 ii 是慢指针，jj 是快指针。</span><br><span class="line"></span><br><span class="line">算法</span><br><span class="line"></span><br><span class="line">当 nums[j]nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] \neq valnums[j] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> =val，我们就复制 nums[j]nums[j] 到 nums[i]nums[i] 并同时递增两个索引。重复这一过程，直到 jj 到达数组的末尾，该数组的新长度为 ii。</span><br><span class="line"></span><br><span class="line">该解法与 删除排序数组中的重复项 的解法十分相似。</span><br><span class="line"></span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n)O(n)，</span><br><span class="line">假设数组总共有 nn 个元素，ii 和 jj 至少遍历 2n2n 步。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(<span class="number">1</span>)O(<span class="number">1</span>)。</span><br><span class="line"></span><br><span class="line">方法二：双指针 —— 当要删除的元素很少时</span><br><span class="line">思路</span><br><span class="line"></span><br><span class="line">现在考虑数组包含很少的要删除的元素的情况。例如，num=[<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">4</span>]，Val=4num=[<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">4</span>]，Val=<span class="number">4</span>。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[<span class="number">4</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>]，Val=4num=[<span class="number">4</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>]，Val=<span class="number">4</span>。似乎没有必要将 [<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>][<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。</span><br><span class="line"></span><br><span class="line">算法</span><br><span class="line"></span><br><span class="line">当我们遇到 nums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。</span><br><span class="line"></span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[n - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// reduce array size by one</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n)O(n)，ii 和 nn 最多遍历 nn 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(<span class="number">1</span>)O(<span class="number">1</span>)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣26删除排序数组中的重复项"><a href="#力扣26删除排序数组中的重复项" class="headerlink" title="力扣26删除排序数组中的重复项"></a>力扣26删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">解法： 双指针</span><br><span class="line"></span><br><span class="line">首先注意数组是有序的，那么重复的元素一定会相邻。</span><br><span class="line"></span><br><span class="line">要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。</span><br><span class="line"></span><br><span class="line">考虑用 <span class="number">2</span> 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>比较 p 和 q 位置的元素是否相等。</span><br><span class="line"></span><br><span class="line">如果相等，q 后移 <span class="number">1</span> 位</span><br><span class="line">如果不相等，将 q 位置的元素复制到 p+<span class="number">1</span> 位置上，p 后移一位，q 后移 <span class="number">1</span> 位</span><br><span class="line">重复上述过程，直到 q 等于数组长度。</span><br><span class="line"></span><br><span class="line">返回 p + <span class="number">1</span>，即为新数组长度。</span><br><span class="line"></span><br><span class="line">画个图理解一下</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105204804236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line"><span class="number">1</span>、判断是否为空</span><br><span class="line"><span class="number">2</span>、双指针p=<span class="number">0</span> q=<span class="number">0</span>  一快一慢</span><br><span class="line"><span class="number">3</span>、循环体(直到遍历完整个数组)&#123;</span><br><span class="line">p索引和q索引是否相等</span><br><span class="line">不相等：将q索引下的值送入q+<span class="number">1</span>索引</span><br><span class="line">更新p索引到p+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>、返回值 p+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[p] != nums[q])&#123;</span><br><span class="line">            nums[p + <span class="number">1</span>] = nums[q];</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/04/18/%E5%8A%9B%E6%89%A31/"/>
      <url>2021/04/18/%E5%8A%9B%E6%89%A31/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210410200442357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1230;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BHBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str = <span class="string">&quot;covid2019&quot;</span>;</span><br><span class="line">System.out.println(reformat(str));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reformat</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] a = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                num1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(num1-num2)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1&gt;num2)&#123;</span><br><span class="line">            num1=<span class="number">0</span>;</span><br><span class="line">            num2=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num2=<span class="number">0</span>;</span><br><span class="line">            num1=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                a[num1] = c;</span><br><span class="line">                num1 += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[num2] = c;</span><br><span class="line">                num2 += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;hash.get(target-nums[i]),i&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">思路  当左右相等时，我们将两个都取或（<span class="number">0</span>变<span class="number">1</span> <span class="number">1</span>变<span class="number">0</span>）</span><br><span class="line">当左右不等时，经过水平互换，再经过<span class="number">01</span>互换相当于不变</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] image) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = image.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (image[i][left] == image[i][right]) &#123;</span><br><span class="line">                    image[i][left] ^= <span class="number">1</span>;</span><br><span class="line">                    image[i][right] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                image[i][left] ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021040609522037.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kLengthApart</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先考虑特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//当碰到1时判断后面的k个数有没有1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length &amp;&amp; j &lt;= i + k; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果都为0，则i跳到i+k+1</span></span><br><span class="line">                i += k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210406101308348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">注意：测试样例可能存在超大数字，所以，一般二分查找问题都会用到<span class="keyword">long</span>型数据，养成习惯</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">long</span> right = num/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid==num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid&gt;num)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid&lt;num)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021040621070839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = stack.pop();</span><br><span class="line">        ListNode dummy = node;</span><br><span class="line">        <span class="comment">//栈中的结点全部出栈，然后重新连成一个新的链表</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ListNode tempNode = stack.pop();</span><br><span class="line">            node.next = tempNode;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个结点就是反转前的头结点，一定要让他的next</span></span><br><span class="line">        <span class="comment">//等于空，否则会构成环</span></span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210406212055243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210406212414777.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">思路：<span class="number">1</span>、找到第一个前边小于后边的数字a[i]</span><br><span class="line">  <span class="number">2</span>、从后向前找第一个大于a[i]的数字，并交换顺序</span><br><span class="line">  <span class="number">3</span>、将i+<span class="number">1</span>到n（左闭右开）反转</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = start, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210406222428180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">力扣<span class="number">48</span>删除最长不含重复字符的子串</span><br><span class="line">细节：i只有在添加元素的时候才增长，否则不用增长</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(arr[i]))&#123;</span><br><span class="line">                <span class="keyword">while</span>(set.contains(arr[i]))&#123;</span><br><span class="line">                    set.remove(arr[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(arr[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(i-j,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210401225906758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span> countIncrease = <span class="number">0</span>, countDecrease = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt;= A[i + <span class="number">1</span>])</span><br><span class="line">                countIncrease++;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt;= A[i + <span class="number">1</span>])</span><br><span class="line">                countDecrease++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countIncrease == len - <span class="number">1</span> || countDecrease == len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里插入图片描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">思路<span class="number">1</span>：找出链表长度，遍历两次</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = length(head);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == len-k)&#123;</span><br><span class="line">                <span class="keyword">return</span> head.val;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">思路<span class="number">2</span>：利用双指针，控制两个指针之间的距离为k,当快指针结束的时候，慢指针即为所求</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode p = dummyHead;</span><br><span class="line">        ListNode q = dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210312152816885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路深度优先搜索，只要当前点满足条件，就往下一步出发</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(visited, m, n, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || visited[i][j] || bitSum(i) + bitSum(j) &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(visited, m, n, k, i + <span class="number">1</span>, j) + dfs(visited, m, n, k, i, j + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bitSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210312160702230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210312160645630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;  重新遍历一遍head</span><br><span class="line">        <span class="comment">// 4. 构建新链表的 next 和 random 指向</span></span><br><span class="line">        操作：get(cur).next表示的是keyvalue的next，而get(cur.next)指的是cur.next对应的键值，也就是复制的cur.next</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210312165817246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">进栈时考虑  如果不是最小值，就入栈一个最小栈的栈顶元素</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s2;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s2=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.add(x);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty()||s2.peek()&gt;x)</span><br><span class="line">            s2.add(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s2.add(s2.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">入栈时，判断是不是最小值</span><br><span class="line">如果是，最小栈入栈</span><br><span class="line">出栈时，判断出栈的是不是最小值</span><br><span class="line">如果是，最小栈出栈</span><br><span class="line">二者的相似之处，维护最小栈栈顶元素为最小值</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2.push(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(stack2.peek()&gt;=x)&#123;</span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min =stack2.peek();</span><br><span class="line">        <span class="keyword">if</span>(stack1.peek() == min)&#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210401225906758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span> countIncrease = <span class="number">0</span>, countDecrease = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt;= A[i + <span class="number">1</span>])</span><br><span class="line">                countIncrease++;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt;= A[i + <span class="number">1</span>])</span><br><span class="line">                countDecrease++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countIncrease == len - <span class="number">1</span> || countDecrease == len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里插入图片描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">思路<span class="number">1</span>：找出链表长度，遍历两次</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = length(head);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == len-k)&#123;</span><br><span class="line">                <span class="keyword">return</span> head.val;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">思路<span class="number">2</span>：利用双指针，控制两个指针之间的距离为k,当快指针结束的时候，慢指针即为所求</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode p = dummyHead;</span><br><span class="line">        ListNode q = dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210312152816885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路深度优先搜索，只要当前点满足条件，就往下一步出发</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(visited, m, n, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || visited[i][j] || bitSum(i) + bitSum(j) &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(visited, m, n, k, i + <span class="number">1</span>, j) + dfs(visited, m, n, k, i, j + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bitSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210312160702230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210312160645630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;  重新遍历一遍head</span><br><span class="line">        <span class="comment">// 4. 构建新链表的 next 和 random 指向</span></span><br><span class="line">        操作：get(cur).next表示的是keyvalue的next，而get(cur.next)指的是cur.next对应的键值，也就是复制的cur.next</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210312165817246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">进栈时考虑  如果不是最小值，就入栈一个最小栈的栈顶元素</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s2;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s2=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.add(x);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty()||s2.peek()&gt;x)</span><br><span class="line">            s2.add(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s2.add(s2.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">入栈时，判断是不是最小值</span><br><span class="line">如果是，最小栈入栈</span><br><span class="line">出栈时，判断出栈的是不是最小值</span><br><span class="line">如果是，最小栈出栈</span><br><span class="line">二者的相似之处，维护最小栈栈顶元素为最小值</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2.push(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(stack2.peek()&gt;=x)&#123;</span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min =stack2.peek();</span><br><span class="line">        <span class="keyword">if</span>(stack1.peek() == min)&#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>陌陌面试算法频率<br><img src="https://img-blog.csdnimg.cn/20210315090458192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210315084919327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210315085004102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">递归：</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / (x * myPow(x, - n - <span class="number">1</span>));含义：<span class="keyword">return</span> <span class="number">1</span>/(myPow(x,-n)) 或者 <span class="keyword">return</span> myPow(<span class="number">1</span>/x,-n)会出现错误</span><br><span class="line">错误原因未知</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / (x * myPow(x, - n - <span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x * myPow(x, n - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> myPow(x * x, n / <span class="number">2</span>);</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315091127221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意指针变换条件<br>当height[l]&lt;height[r]时，只能移动较小的，因为移动较大的一个只会导致area越来越小，因为area由小的决定，r-l减小。只能希望高度增加。所以通过移动小的来增加高度，才可能得到的较大的面积</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = Math.min(height[l],height[r])*(r-l);</span><br><span class="line">            ans = Math.max(area,ans);</span><br><span class="line">            <span class="keyword">if</span>(height[l]&lt;height[r]) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315092640422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>思路：HashMap用来存储数值和索引，因为他只有两个值，所以不需要回溯算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;hash.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315102440607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = str.trim().toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = ch.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>||str.length()==<span class="number">0</span>||str==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bdny = Integer.MAX_VALUE/<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[j]&lt;<span class="string">&#x27;0&#x27;</span>||ch[j]&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ret&gt;bdny||(ret==bdny&amp;&amp;ch[j]&gt;<span class="string">&#x27;7&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> sign&gt;<span class="number">0</span>?Integer.MAX_VALUE:Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = ret*<span class="number">10</span>+ch[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign*ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315160743893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">完整代码刻在eclipse运行</span><br><span class="line"><span class="keyword">package</span> leetcode1230;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">100</span>&#125;;</span><br><span class="line">System.out.println(f(arr1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.containsKey(nums[i]))&#123;</span><br><span class="line">        hash.put(nums[i],hash.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        hash.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.get(nums[i])==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315164431181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1230;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twoSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span>[] ret = f(nums,target);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ret.length; i++)&#123;</span><br><span class="line">System.out.println(ret[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] f(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(nums[i]))&#123;</span><br><span class="line">                hash.put(nums[i],hash.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hash.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==(target-nums[i]))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(hash.get(nums[i])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],target-nums[i]&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],target-nums[i]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315230842366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 第一段代码是错的，还未找到错误原因</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) que.add(root);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; ls  = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                TreeNode ans = que.poll();</span><br><span class="line">                <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">1</span>) ls.addLast(ans.val); <span class="comment">// 偶数层 -&gt; 队列头部</span></span><br><span class="line">                <span class="keyword">else</span> ls.addFirst(ans.val);</span><br><span class="line">                <span class="keyword">if</span>(ans.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    que.add(ans.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    que.add(ans.left);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">            ret.add(ls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>) tmp.addLast(node.val); <span class="comment">// 偶数层 -&gt; 队列头部</span></span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val); <span class="comment">// 奇数层 -&gt; 队列尾部</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315160743893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">完整代码刻在eclipse运行</span><br><span class="line"><span class="keyword">package</span> leetcode1230;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">100</span>&#125;;</span><br><span class="line">System.out.println(f(arr1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.containsKey(nums[i]))&#123;</span><br><span class="line">        hash.put(nums[i],hash.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        hash.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.get(nums[i])==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315164431181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1230;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twoSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span>[] ret = f(nums,target);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ret.length; i++)&#123;</span><br><span class="line">System.out.println(ret[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] f(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(nums[i]))&#123;</span><br><span class="line">                hash.put(nums[i],hash.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hash.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==(target-nums[i]))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(hash.get(nums[i])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],target-nums[i]&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],target-nums[i]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315230842366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 第一段代码是错的，还未找到错误原因</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) que.add(root);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; ls  = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                TreeNode ans = que.poll();</span><br><span class="line">                <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">1</span>) ls.addLast(ans.val); <span class="comment">// 偶数层 -&gt; 队列头部</span></span><br><span class="line">                <span class="keyword">else</span> ls.addFirst(ans.val);</span><br><span class="line">                <span class="keyword">if</span>(ans.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    que.add(ans.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    que.add(ans.left);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">            ret.add(ls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>) tmp.addLast(node.val); <span class="comment">// 偶数层 -&gt; 队列头部</span></span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val); <span class="comment">// 奇数层 -&gt; 队列尾部</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210308221140562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root==p || root==q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果left为空，那么说明p和q都不在左子树，所以直接返回右节点</span></span><br><span class="line">        <span class="comment">//同理</span></span><br><span class="line">        <span class="comment">//如果left和right都为空，说明p和q在两侧，所以返回root</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210308223342410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        backtrack(<span class="number">0</span>,nums,ls,ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; ls,List&lt;List&lt;Integer&gt;&gt; ret)</span></span>&#123;</span><br><span class="line">        ret.add(<span class="keyword">new</span> ArrayList&lt;&gt;(ls));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;nums.length; i++)&#123;</span><br><span class="line">            ls.add(nums[i]);</span><br><span class="line">            backtrack(i+<span class="number">1</span>,nums,ls,ret);</span><br><span class="line">            ls.remove(ls.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210308232720260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = flowerbed.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;flowerbed.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i]==<span class="number">0</span>&amp;&amp;(i==<span class="number">0</span>||flowerbed[i-<span class="number">1</span>]==<span class="number">0</span>)&amp;&amp;(i==len-<span class="number">1</span>||flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">                flowerbed[i]=<span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315160743893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">完整代码刻在eclipse运行</span><br><span class="line"><span class="keyword">package</span> leetcode1230;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">100</span>&#125;;</span><br><span class="line">System.out.println(f(arr1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.containsKey(nums[i]))&#123;</span><br><span class="line">        hash.put(nums[i],hash.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        hash.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.get(nums[i])==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315164431181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1230;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twoSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span>[] ret = f(nums,target);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ret.length; i++)&#123;</span><br><span class="line">System.out.println(ret[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] f(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(nums[i]))&#123;</span><br><span class="line">                hash.put(nums[i],hash.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hash.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==(target-nums[i]))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(hash.get(nums[i])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],target-nums[i]&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],target-nums[i]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315230842366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 第一段代码是错的，还未找到错误原因</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) que.add(root);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; ls  = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                TreeNode ans = que.poll();</span><br><span class="line">                <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">1</span>) ls.addLast(ans.val); <span class="comment">// 偶数层 -&gt; 队列头部</span></span><br><span class="line">                <span class="keyword">else</span> ls.addFirst(ans.val);</span><br><span class="line">                <span class="keyword">if</span>(ans.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    que.add(ans.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    que.add(ans.left);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">            ret.add(ls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>) tmp.addLast(node.val); <span class="comment">// 偶数层 -&gt; 队列头部</span></span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val); <span class="comment">// 奇数层 -&gt; 队列尾部</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210227153124935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227153130697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：<br>    暴力解法需要重复运算N-1次<br>    可以根据中间结果取平方的方式进行运算<br>    每次保存上一个结果的平方或平方<em>x<br>    取决于N取余时是否整除<br>    整除取平方  不整除取平方</em>x</p><p><img src="https://img-blog.csdnimg.cn/20210227155037127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021022715522896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227155238345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227155244214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">// f[i][0]: 手上持有股票的最大收益</span></span><br><span class="line">        <span class="comment">// f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益</span></span><br><span class="line">        <span class="comment">// f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益</span></span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//第一天持有股票  需要减去第一天的价格</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//第一天不持有股票，</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">//第一天不持有股票，这两行没有也要被定义数组时初始化为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            f[i][<span class="number">2</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(f[n - <span class="number">1</span>][<span class="number">1</span>], f[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021022716104334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227161225323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227161240124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227161250874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;![在这里插入图片描述](https:<span class="comment">//img-blog.csdnimg.cn/2021012813202067.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)</span></span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">思路：</span><br><span class="line">判断是不是叶子节点</span><br><span class="line">右节点中也有左叶子节点</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="keyword">null</span> ? dfs(root) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans += isLeafNode(node.left) ? node.left.val : dfs(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span> &amp;&amp; !isLeafNode(node.right)) &#123;</span><br><span class="line">            ans += dfs(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeafNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) </span><br><span class="line">            + sumOfLeftLeaves(root.right) </span><br><span class="line">            + (root.left!=<span class="keyword">null</span> &amp;&amp; root.left.left==<span class="keyword">null</span> &amp;&amp; root.left.right==<span class="keyword">null</span> ? root.left.val : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​```</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣566重塑数组"><a href="#力扣566重塑数组" class="headerlink" title="力扣566重塑数组"></a>力扣566重塑数组</h2><p><img src="https://img-blog.csdnimg.cn/20210217103014600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210217103020734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210217103024273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210305231220118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>思路：<br>1、规定4个方向数组  决定下一次的前进方向<br>2、建立访问数组，标记每个数组是否访问过</p><p>注意改变前进方向的条件（下一个数组行超限 || 列超限（&gt;=len || &lt;0） || 下一个位置遍历过）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> total = row*col;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[total];</span><br><span class="line">        <span class="keyword">int</span>[][] dir = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] been = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        <span class="keyword">int</span> directionindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;total; i++)&#123;</span><br><span class="line">            ans[i] = matrix[row0][col0];</span><br><span class="line">            been[row0][col0] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> next0 = row0+dir[directionindex][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> next1 = col0+dir[directionindex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(next0&lt;<span class="number">0</span>||next0&gt;=row||next1&gt;=col||next1&lt;<span class="number">0</span>||been[next0][next1]==<span class="keyword">true</span>)&#123;</span><br><span class="line">                directionindex++;</span><br><span class="line">                <span class="keyword">if</span>(directionindex==<span class="number">4</span>) directionindex=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row0 = row0 + dir[directionindex][<span class="number">0</span>];</span><br><span class="line">            col0 = col0 + dir[directionindex][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复习对称二叉树<br>镜像二叉树</p><p>力扣 根据前序遍历和中序遍历确定二叉树<br><img src="https://img-blog.csdnimg.cn/20210304084422516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202103040845552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>基本思路<br>前序遍历确定根节点是哪个（第一个就是根节点）<br>中序遍历根据已知根节点确定左右子树的元素组成<br>根节点左  左子树<br>根节点右  右子树<br>再根据前序遍历确定  左子树的根节点<br>根据左子树的根节点确定   左子树元素的左右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">理解：每次更新的是提供的前序遍历序列和中序遍历序列 ，官方答案提供的是更新索引，不更新前、中序遍历</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(preorder.length==<span class="number">0</span> || inorder.length==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据前序数组的第一个元素，就可以确定根节点</span></span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;preorder.length;++i) &#123;</span><br><span class="line"><span class="comment">//用preorder[0]去中序数组中查找对应的元素</span></span><br><span class="line"><span class="keyword">if</span>(preorder[<span class="number">0</span>]==inorder[i]) &#123;</span><br><span class="line"><span class="comment">//将前序数组分成左右两半，再将中序数组分成左右两半</span></span><br><span class="line"><span class="comment">//之后递归的处理前序数组的左边部分和中序数组的左边部分</span></span><br><span class="line"><span class="comment">//递归处理前序数组右边部分和中序数组右边部分</span></span><br><span class="line"><span class="keyword">int</span>[] pre_left = Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span>[] pre_right = Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length);</span><br><span class="line"><span class="keyword">int</span>[] in_left = Arrays.copyOfRange(inorder,<span class="number">0</span>,i);</span><br><span class="line"><span class="keyword">int</span>[] in_right = Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length);</span><br><span class="line">root.left = buildTree(pre_left,in_left);</span><br><span class="line">root.right = buildTree(pre_right,in_right);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021030410342839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">// 默认初始化值都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i; <span class="comment">// 最坏的情况就是每次+1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; j++) &#123; </span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>); <span class="comment">// 动态转移 </span></span><br><span class="line">                <span class="comment">//dp[0]=0，当i-j*j=0时，说明只需要一次就可以，如果i-j*j！=0时，说明我们需要根据前面的最优结果进行+1</span></span><br><span class="line">                <span class="comment">//例如5  因为4的最优只有1个即可，因此5只需在4的基础上+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快速排序思想<br>1、第一轮   最左侧元素作为Key值（目标：&gt;Key 右侧，&lt;Key 左侧）<br>    双指针放在第二个元素和最后一个元素<br>        （1）从r指针开始，寻找小于Key的元素，找到时停下<br>        （2）从l指针开始，寻找大于Key的元素，找到时停下，交换l、r指针元素的位置<br>        （3）重复（1）直到左右指针重合（l=r）<br>        （4）重合后将l指针元素与Key交换顺序（实现了左&lt;Key右&gt;Key）<br>2、将Key左侧的作为新的待排列的数组，重复1操作<br>      将Key右侧的作为新的待排列的数组，重复1操作<br>3、排列完成标志  l&gt;r或者输入数组为空时说明排列完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        quicksort(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] quicksort(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Key = nums[start];</span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;=Key)&#123;  <span class="comment">//从右向左找到&lt;Key的值终止循环</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=Key)&#123; <span class="comment">//从左向右找到&gt;Key的值终止循环</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                swap(nums,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">                swap(nums,start,left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quicksort(nums,left+<span class="number">1</span>,end);</span><br><span class="line">        quicksort(nums,start,left-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序 核心思想（两两有序合并）<br>1、将序列中待排序数字分为若干组，每个数字分为一组<br>2、将若干个组凉凉合并，保证合并后的数组是有序的<br>3、重复第二部操直到只剩下一组</p><p>两两合并原则：，比较两组数据头部大小，将小的放入新的序列，更新头部指针，重复操作</p><h2 id="剑指offer57-和为S的连续正数序列"><a href="#剑指offer57-和为S的连续正数序列" class="headerlink" title="剑指offer57 和为S的连续正数序列"></a>剑指offer57 和为S的连续正数序列</h2><p><img src="https://img-blog.csdnimg.cn/20210127154438356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021012716105393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">思路</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;l&lt;r;)&#123;</span><br><span class="line">            sum = (l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123;</span><br><span class="line">                    res[i-l] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(res);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = result.size();</span><br><span class="line">        <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[len][];</span><br><span class="line">        result.toArray(a);</span><br><span class="line">        <span class="keyword">return</span> a; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣1013-将数组分成和相等的三个部分"><a href="#力扣1013-将数组分成和相等的三个部分" class="headerlink" title="力扣1013 将数组分成和相等的三个部分"></a>力扣1013 将数组分成和相等的三个部分</h2><p><img src="https://img-blog.csdnimg.cn/20210127164941426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : A)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 总和不是3的倍数，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用双指针,从数组两头开始一起找，节约时间</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSum = A[left];</span><br><span class="line">        <span class="keyword">int</span> right = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightSum = A[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用left + 1 &lt; right 的原因，防止只能将数组分成两个部分</span></span><br><span class="line">        <span class="comment">// 例如：[1,-1,1,-1]，使用left &lt; right作为判断条件就会出错</span></span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftSum == sum/<span class="number">3</span> &amp;&amp; rightSum == sum/<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">// 左右两边都等于 sum/3 ，中间也一定等于</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftSum != sum/<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">// left = 0赋予了初值，应该先left++，在leftSum += A[left];</span></span><br><span class="line">                leftSum += A[++left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rightSum != sum/<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">// right = A.length - 1 赋予了初值，应该先right--，在rightSum += A[right];</span></span><br><span class="line">                rightSum += A[--right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣112-路径总和"><a href="#力扣112-路径总和" class="headerlink" title="力扣112 路径总和"></a>力扣112 路径总和</h2><p><img src="https://img-blog.csdnimg.cn/20210127191436920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">思路：当节点为空时，那么说明这条路没有</span></span><br><span class="line"><span class="comment">当节点没有子节点是，返回这个节点是不是和输入的目标差相同，相同则说明找到了满足条件的路径</span></span><br><span class="line"><span class="comment">当节点不为空时，将当前节点移动到它的左右子节点进行判断，同时输入的目标也应该减去当前节点的val</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val == sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210122224942528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210122225042234.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">思路  用List从低位到高位依次存储，然后Collections.reverse(res);逆置列表</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = A[i] + K % <span class="number">10</span>;</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                K++;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; K &gt; <span class="number">0</span>; K /= <span class="number">10</span>) &#123;</span><br><span class="line">            res.add(K % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210122225047244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span> || K &gt; <span class="number">0</span>; --i, K /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                K += A[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(K % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣965-单值二叉树"><a href="#力扣965-单值二叉树" class="headerlink" title="力扣965 单值二叉树"></a>力扣965 单值二叉树</h2><p><img src="https://img-blog.csdnimg.cn/20210121194127548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isUnivalTree</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line">            val = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val != val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isUnivalTree(root.left)&amp;&amp;isUnivalTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210121194341508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isUnivalTree</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">        boolean flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = isUnivalTree(root.left);</span><br><span class="line">        flag &amp;=isUnivalTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((root.left!=<span class="literal">null</span> &amp;&amp; root.left.val!=root.val) || (root.right!=<span class="literal">null</span> &amp;&amp; root.right.val!=root.val)) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣617-合并二叉树"><a href="#力扣617-合并二叉树" class="headerlink" title="力扣617 合并二叉树"></a>力扣617 合并二叉树</h2><p><img src="https://img-blog.csdnimg.cn/20210121201204114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span>(<span class="params">TreeNode t1, TreeNode t2</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode merge = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">        merge.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        merge.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> merge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣167-两数之和2"><a href="#力扣167-两数之和2" class="headerlink" title="力扣167 两数之和2"></a>力扣167 两数之和2</h2><p><img src="https://img-blog.csdnimg.cn/20210121215501670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210121215412564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">twoSum</span>(<span class="params"><span class="built_in">int</span>[] numbers, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> len = numbers.length;</span><br><span class="line">        <span class="built_in">int</span> k2 = len<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> k1 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(k1&lt;k2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[k1]+numbers[k2]==target)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = k1+<span class="number">1</span>;</span><br><span class="line">                result[<span class="number">1</span>] = k2+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numbers[k1]+numbers[k2]&gt;target)&#123;</span><br><span class="line">                k2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指offer11-旋转数组的最小数字"><a href="#剑指offer11-旋转数组的最小数字" class="headerlink" title="剑指offer11 旋转数组的最小数字"></a>剑指offer11 旋转数组的最小数字</h2><p><img src="https://img-blog.csdnimg.cn/20210121221723457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="s"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">minArray</span>(<span class="params"><span class="built_in">int</span>[] numbers</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;numbers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]&lt;numbers[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指offer09-用两个栈实现队列"><a href="#剑指offer09-用两个栈实现队列" class="headerlink" title="剑指offer09 用两个栈实现队列"></a>剑指offer09 用两个栈实现队列</h2><p><img src="https://img-blog.csdnimg.cn/20210121224605700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">思路：用两个栈   栈<span class="number">1</span>用来增加元素，stack1.push即可</span><br><span class="line">栈<span class="number">2</span>用来删除元素，首先，当栈<span class="number">2</span>不为空时，直接pop()</span><br><span class="line">当栈<span class="number">2</span>为空时，将刚刚增加的元素（栈<span class="number">1</span>中的元素依次入栈，可能是多个，可以理解为栈<span class="number">1</span>是栈<span class="number">2</span>的仓库，没有了就来拿），当栈<span class="number">2</span>仍然为空时（栈<span class="number">1</span>也是空的，栈<span class="number">2</span>也是空的），返回-<span class="number">1</span>。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> head = stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="剑指offer18-删除链表中的节点"><a href="#剑指offer18-删除链表中的节点" class="headerlink" title="剑指offer18 删除链表中的节点"></a>剑指offer18 删除链表中的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode a = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode b = a;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != val)&#123;</span><br><span class="line">                ListNode ans = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">                a.next = ans;</span><br><span class="line">                a = a.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题0-06-回文链表"><a href="#面试题0-06-回文链表" class="headerlink" title="面试题0..06 回文链表"></a>面试题0..06 回文链表</h2><p>编写一个函数，检查输入的链表是否是回文的。</p><p>示例 1：</p><p>输入： 1-&gt;2<br>输出： false<br>示例 2：</p><p>输入： 1-&gt;2-&gt;2-&gt;1<br>输出： true </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">思路：将原链表的值全部送入栈中（倒置链表值）</span><br><span class="line">将链表中的值与栈中的值依次送出，比较是否相同（比较len/<span class="number">2</span>次即可）</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        ListNode a = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        a = a.next;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(a.val);</span><br><span class="line">            a = a.next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;num/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans1 = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> ans2 = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span>(ans1 != ans2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣1290-二进制链表转整数"><a href="#力扣1290-二进制链表转整数" class="headerlink" title="力扣1290 二进制链表转整数"></a>力扣1290 二进制链表转整数</h2><p><img src="https://img-blog.csdnimg.cn/20210120211236489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = getLength(head);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            sum += head.val * Math.pow(<span class="number">2</span>,len-<span class="number">1</span>-i);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; </span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum = (sum &lt;&lt; <span class="number">1</span>) + head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="剑指offer25合并两个排序的链表"><a href="#剑指offer25合并两个排序的链表" class="headerlink" title="剑指offer25合并两个排序的链表"></a>剑指offer25合并两个排序的链表</h2><p><img src="https://img-blog.csdnimg.cn/20210120213016755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = getLength(l1);</span><br><span class="line">        <span class="keyword">int</span> len2 = getLength(l2);</span><br><span class="line">        <span class="keyword">if</span>(len1 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len1+len2];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len1; i++)&#123;</span><br><span class="line">            arr[i] = l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len1; i&lt;len1+len2; i++)&#123;</span><br><span class="line">            arr[i] = l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(arr[<span class="number">0</span>]);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len1+len2; i++)&#123;</span><br><span class="line">            ListNode ans = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">            head.next = ans;</span><br><span class="line">            head = head.next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210120213145372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dum = <span class="keyword">new</span> ListNode(<span class="number">0</span>), cur = dum;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣328-奇偶链表"><a href="#力扣328-奇偶链表" class="headerlink" title="力扣328 奇偶链表"></a>力扣328 奇偶链表</h2><p><img src="https://img-blog.csdnimg.cn/20210120214252873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">有问题   需要开辟新空间的方法，</span><br><span class="line">即链表的空间复杂度为O(N)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode a = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur1 = a;</span><br><span class="line">        ListNode b = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur2 = b;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                ListNode ans1 = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">                a.next = ans1;</span><br><span class="line">                a = a.next;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode ans2 = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">                b.next = ans2;</span><br><span class="line">                b = b.next;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        a.next = cur2.next;</span><br><span class="line">        <span class="keyword">return</span> cur1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣23-合并K个升序链表"><a href="#力扣23-合并K个升序链表" class="headerlink" title="力扣23 合并K个升序链表"></a>力扣23 合并K个升序链表</h2><p><img src="https://img-blog.csdnimg.cn/20210120224637120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">朴素法：</span><br><span class="line">遍历链表数组，每次将两个链表合并排序，返回新的链表</span><br><span class="line">合并两个有序链表参考剑指offer25</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; ++i) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = getLength(l1);</span><br><span class="line">        <span class="keyword">int</span> len2 = getLength(l2);</span><br><span class="line">        <span class="keyword">if</span>(len1 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len1+len2];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len1; i++)&#123;</span><br><span class="line">            arr[i] = l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len1; i&lt;len1+len2; i++)&#123;</span><br><span class="line">            arr[i] = l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(arr[<span class="number">0</span>]);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len1+len2; i++)&#123;</span><br><span class="line">            ListNode ans = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">            head.next = ans;</span><br><span class="line">            head = head.next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; ++i) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a != <span class="keyword">null</span> ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tail = head, aPtr = a, bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr != <span class="keyword">null</span> &amp;&amp; bPtr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">                tail.next = aPtr;</span><br><span class="line">                aPtr = aPtr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = bPtr;</span><br><span class="line">                bPtr = bPtr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = (aPtr != <span class="keyword">null</span> ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣628-三个数的最大乘积"><a href="#力扣628-三个数的最大乘积" class="headerlink" title="力扣628 三个数的最大乘积"></a>力扣628 三个数的最大乘积</h2><p>方法一：排序<br>首先将数组排序。</p><p>如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。</p><p>如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。</p><p>综上，我们在给数组排序后，分别求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最小的两个和最大值：处理最小值为负数时</span><br><span class="line">max（最大的三个的积，最小的两个数和最大值的积）  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[n - <span class="number">1</span>], nums[n - <span class="number">3</span>] * nums[n - <span class="number">2</span>] * nums[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(N\log N)O(NlogN)，其中 NN 为数组长度。排序需要 O(N\log N)O(NlogN) 的时间。</p><p>空间复杂度：O(\log N)O(logN)，主要为排序的空间开销。</p><p>方法二：线性扫描<br>在方法一中，我们实际上只要求出数组中最大的三个数以及最小的两个数，因此我们可以不用排序，用线性扫描直接得出这五个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最小的和第二小的</span></span><br><span class="line">        <span class="keyword">int</span> min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 最大的、第二大的和第三大的</span></span><br><span class="line">        <span class="keyword">int</span> max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; min2) &#123;</span><br><span class="line">                min2 = x;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x &gt; max1) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max2) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max3) &#123;</span><br><span class="line">                max3 = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(min1 * min2 * max1, max1 * max2 * max3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣122-买卖股票的最佳时机"><a href="#力扣122-买卖股票的最佳时机" class="headerlink" title="力扣122 买卖股票的最佳时机"></a>力扣122 买卖股票的最佳时机</h2><p><img src="https://img-blog.csdnimg.cn/20210120143543138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210120143208224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) profit += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣876-链表的中间节点"><a href="#力扣876-链表的中间节点" class="headerlink" title="力扣876 链表的中间节点"></a>力扣876 链表的中间节点</h2><p>法一：遍历一次记录链表长度   除以二取中间找到该节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">方法三：快慢指针法</span><br><span class="line">思路和算法</span><br><span class="line"></span><br><span class="line">我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。</span><br><span class="line"></span><br><span class="line">C++JavaPythonJavaScript</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* middleNode(ListNode* head) &#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07 链表相交"></a>面试题 02.07 链表相交</h2><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</p><p>示例 1：</p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。<br><img src="https://img-blog.csdnimg.cn/20210120152501911.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">注意：当没有交点时，二者会同时指向<span class="keyword">null</span>，因此也满足t1==t2的条件，终止循环</span><br><span class="line">当有交点时，会在交点处终止循环</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode t1 = headA;</span><br><span class="line">        ListNode t2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(t1 != t2)&#123;</span><br><span class="line">            t1 = t1 != <span class="keyword">null</span> ? t1.next : headB;</span><br><span class="line">            t2 = t2 != <span class="keyword">null</span> ? t2.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="203、移除链表元素"><a href="#203、移除链表元素" class="headerlink" title="203、移除链表元素"></a>203、移除链表元素</h2><p>删除链表中等于给定值 val 的所有节点。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode sentinel = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        sentinel.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode prev = sentinel, curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.val == val) prev.next = curr.next;</span><br><span class="line">            <span class="keyword">else</span> prev = curr;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="力扣19删除链表的倒数第n个节点"><a href="#力扣19删除链表的倒数第n个节点" class="headerlink" title="力扣19删除链表的倒数第n个节点"></a>力扣19删除链表的倒数第n个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">思路:链表题涉及到位置索引的可以通过设计方法来求链表长度</span><br><span class="line">注意，初始化一个纸箱head的节点列表：ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">首先现找到倒数第n-<span class="number">1</span>个节点</span><br><span class="line">寻找方法，通过<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len-n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    cur.next = cur.next.next;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        <span class="keyword">int</span> len = getlength(head);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len-n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getlength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣225用队列实现栈"><a href="#力扣225用队列实现栈" class="headerlink" title="力扣225用队列实现栈"></a>力扣225用队列实现栈</h2><p>队列的基本操作<br>add和offer都是增加元素  ，add在超出范围时会报错<br>offer不会理解报错<br>poll获取并移除队列的头<br>element获取队列的头  若为空则抛出异常<br>peek也是获取队列的头，若为空曾返回null<br><img src="https://img-blog.csdnimg.cn/2021011813110063.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210118131103517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210118131219337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用队列实现栈的下列操作：</p><p>push(x) – 元素 x 入栈<br>pop() – 移除栈顶元素<br>top() – 获取栈顶元素<br>empty() – 返回栈是否为空<br>注意:</p><p>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p><p>解答：<br><img src="https://img-blog.csdnimg.cn/20210118135817588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>在队列中   每送入第n个元素，要将队列的前n-1移出并按送入顺序依次移入序列中，如上图</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">首先明确队列先进先出的方式  </span><br><span class="line"></span><br><span class="line">push: 将队列中总入新元素之后，还要将队列的头元素poll再offer送入队列queue.offer(queue.poll());  重复queue.size次</span><br><span class="line">pop:每次送出队列的头部元素  queue.poll()</span><br><span class="line">top:queue.peek()操作</span><br><span class="line">empty:queue.isEmpty()</span><br><span class="line">方法二：一个队列</span><br><span class="line">方法一使用了两个队列实现栈的操作，也可以使用一个队列实现栈的操作。</span><br><span class="line"></span><br><span class="line">使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。</span><br><span class="line"></span><br><span class="line">入栈操作时，首先获得入栈前的元素个数 nn，然后将元素入队到队列，再将队列中的前 nn 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。</span><br><span class="line"></span><br><span class="line">由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。</span><br><span class="line"></span><br><span class="line">由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="面试题10-01-合并排序的数组"><a href="#面试题10-01-合并排序的数组" class="headerlink" title="面试题10.01 合并排序的数组"></a>面试题10.01 合并排序的数组</h2><p>从A[m]开始依次存入B[0]直到B[n]<br>再排序</p><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p>示例:</p><p>输入:<br>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]<br>说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            A[m + i] = B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣34在排序数组中查找元素的第一个和最后一个位置"><a href="#力扣34在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="力扣34在排序数组中查找元素的第一个和最后一个位置"></a>力扣34在排序数组中查找元素的第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><p>示例 1：</p><p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]<br>示例 2：</p><p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]<br>示例 3：</p><p>输入：nums = [], target = 0<br>输出：[-1,-1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                arr[<span class="number">0</span>]=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[<span class="number">1</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr[<span class="number">0</span>]+<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                arr[<span class="number">1</span>]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣8字符串转换整数："><a href="#力扣8字符串转换整数：" class="headerlink" title="力扣8字符串转换整数："></a>力扣8字符串转换整数：</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p>注意：</p><p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  231 − 1 或 −231 。</p><p>🙋🙋我来了~~ 最近这几天非常忙，leetcode和公众号的消息不能及时回复见谅！我会抽空一条条回复的！现在先来打卡啦~</p><p>这道题目其实出得有点恶心，需要比较仔细才可以通过。当然比这题更恶心的是要需要识别科学计数法，识别二进制(0b01)，八进制（012)，十六进制（0xab），不知道leetcode会不会丧心病狂出这样的题目（或者已经有了？）。。</p><p>这题的做法大概是这样：</p><p>去掉前导空格<br>再是处理正负号<br>识别数字，注意越界情况。<br>这道题目如果只是简单地字符串转整数的话，就是简单地 ans = ans * 10 + digit。<br>但是注意这道题目可能会超过integer的最大表示！<br>也就是说会在某一步 ans * 10 + digit &gt; Integer.MAX_VALUE。<br>*10 和 +digit 都有可能越界，那么只要把这些都移到右边去就可以了。<br>ans &gt; (Integer.MAX_VALUE - digit) / 10 就是越界。</p><p>不过我的忠告是，等真正工作以后，尽可能地调用jdk的方法，比如Character.isDigit。如果没有你想要的api，也要尽量使用guava，apache common等常见的utils包，尽量不要自己造轮子，一是这样减少出错的可能，二是比较无脑，保护脑细胞~</p><p>下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; n &amp;&amp; chars[idx] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 去掉前导空格</span></span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            <span class="comment">//去掉前导空格以后到了末尾了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (chars[idx] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//遇到负号</span></span><br><span class="line">            negative = <span class="keyword">true</span>;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[idx] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到正号</span></span><br><span class="line">            idx++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isDigit(chars[idx])) &#123;</span><br><span class="line">            <span class="comment">// 其他符号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; n &amp;&amp; Character.isDigit(chars[idx])) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = chars[idx] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; (Integer.MAX_VALUE - digit) / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// 本来应该是 ans * 10 + digit &gt; Integer.MAX_VALUE</span></span><br><span class="line">                <span class="comment">// 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。</span></span><br><span class="line">                <span class="keyword">return</span> negative? Integer.MIN_VALUE : Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">10</span> + digit;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣15：三数之和"><a href="#力扣15：三数之和" class="headerlink" title="力扣15：三数之和"></a>力扣15：三数之和</h2><p>思路<br>标签：数组遍历<br>首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和 nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集<br>如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环<br>如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过<br>当 sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，L++L++<br>当 sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R–R−−<br>时间复杂度：O(n^2)O(n<br>2<br> )，nn 为数组长度<br>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">int</span> L = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210119192846592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode aa = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        aa = aa.next;</span><br><span class="line">        <span class="keyword">int</span> len = getlength(head);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            arr[i] = aa.val;</span><br><span class="line">            aa = aa.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"><span class="comment">//show();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        ListNode min = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        ListNode a = min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            min.val = arr[i];</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(i==len-<span class="number">1</span>)&#123;</span><br><span class="line">                min.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            min = min.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getlength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣19删除链表的倒数第n个节点-1"><a href="#力扣19删除链表的倒数第n个节点-1" class="headerlink" title="力扣19删除链表的倒数第n个节点"></a>力扣19删除链表的倒数第n个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">思路:链表题涉及到位置索引的可以通过设计方法来求链表长度</span><br><span class="line">注意，初始化一个纸箱head的节点列表：ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">首先现找到倒数第n-<span class="number">1</span>个节点</span><br><span class="line">寻找方法，通过<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len-n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    cur.next = cur.next.next;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        <span class="keyword">int</span> len = getlength(head);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len-n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getlength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣225用队列实现栈-1"><a href="#力扣225用队列实现栈-1" class="headerlink" title="力扣225用队列实现栈"></a>力扣225用队列实现栈</h2><p>队列的基本操作<br>add和offer都是增加元素  ，add在超出范围时会报错<br>offer不会理解报错<br>poll获取并移除队列的头<br>element获取队列的头  若为空则抛出异常<br>peek也是获取队列的头，若为空曾返回null<br><img src="https://img-blog.csdnimg.cn/2021011813110063.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210118131103517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210118131219337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用队列实现栈的下列操作：</p><p>push(x) – 元素 x 入栈<br>pop() – 移除栈顶元素<br>top() – 获取栈顶元素<br>empty() – 返回栈是否为空<br>注意:</p><p>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p><p>解答：<br><img src="https://img-blog.csdnimg.cn/20210118135817588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>在队列中   每送入第n个元素，要将队列的前n-1移出并按送入顺序依次移入序列中，如上图</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">首先明确队列先进先出的方式  </span><br><span class="line"></span><br><span class="line">push: 将队列中总入新元素之后，还要将队列的头元素poll再offer送入队列queue.offer(queue.poll());  重复queue.size次</span><br><span class="line">pop:每次送出队列的头部元素  queue.poll()</span><br><span class="line">top:queue.peek()操作</span><br><span class="line">empty:queue.isEmpty()</span><br><span class="line">方法二：一个队列</span><br><span class="line">方法一使用了两个队列实现栈的操作，也可以使用一个队列实现栈的操作。</span><br><span class="line"></span><br><span class="line">使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。</span><br><span class="line"></span><br><span class="line">入栈操作时，首先获得入栈前的元素个数 nn，然后将元素入队到队列，再将队列中的前 nn 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。</span><br><span class="line"></span><br><span class="line">由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。</span><br><span class="line"></span><br><span class="line">由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="面试题10-01-合并排序的数组-1"><a href="#面试题10-01-合并排序的数组-1" class="headerlink" title="面试题10.01 合并排序的数组"></a>面试题10.01 合并排序的数组</h2><p>从A[m]开始依次存入B[0]直到B[n]<br>再排序</p><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p>示例:</p><p>输入:<br>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]<br>说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            A[m + i] = B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣34在排序数组中查找元素的第一个和最后一个位置-1"><a href="#力扣34在排序数组中查找元素的第一个和最后一个位置-1" class="headerlink" title="力扣34在排序数组中查找元素的第一个和最后一个位置"></a>力扣34在排序数组中查找元素的第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><p>示例 1：</p><p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]<br>示例 2：</p><p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]<br>示例 3：</p><p>输入：nums = [], target = 0<br>输出：[-1,-1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                arr[<span class="number">0</span>]=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[<span class="number">1</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr[<span class="number">0</span>]+<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                arr[<span class="number">1</span>]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣8字符串转换整数：-1"><a href="#力扣8字符串转换整数：-1" class="headerlink" title="力扣8字符串转换整数："></a>力扣8字符串转换整数：</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p>注意：</p><p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  231 − 1 或 −231 。</p><p>🙋🙋我来了~~ 最近这几天非常忙，leetcode和公众号的消息不能及时回复见谅！我会抽空一条条回复的！现在先来打卡啦~</p><p>这道题目其实出得有点恶心，需要比较仔细才可以通过。当然比这题更恶心的是要需要识别科学计数法，识别二进制(0b01)，八进制（012)，十六进制（0xab），不知道leetcode会不会丧心病狂出这样的题目（或者已经有了？）。。</p><p>这题的做法大概是这样：</p><p>去掉前导空格<br>再是处理正负号<br>识别数字，注意越界情况。<br>这道题目如果只是简单地字符串转整数的话，就是简单地 ans = ans * 10 + digit。<br>但是注意这道题目可能会超过integer的最大表示！<br>也就是说会在某一步 ans * 10 + digit &gt; Integer.MAX_VALUE。<br>*10 和 +digit 都有可能越界，那么只要把这些都移到右边去就可以了。<br>ans &gt; (Integer.MAX_VALUE - digit) / 10 就是越界。</p><p>不过我的忠告是，等真正工作以后，尽可能地调用jdk的方法，比如Character.isDigit。如果没有你想要的api，也要尽量使用guava，apache common等常见的utils包，尽量不要自己造轮子，一是这样减少出错的可能，二是比较无脑，保护脑细胞~</p><p>下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; n &amp;&amp; chars[idx] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 去掉前导空格</span></span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            <span class="comment">//去掉前导空格以后到了末尾了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (chars[idx] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//遇到负号</span></span><br><span class="line">            negative = <span class="keyword">true</span>;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[idx] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到正号</span></span><br><span class="line">            idx++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isDigit(chars[idx])) &#123;</span><br><span class="line">            <span class="comment">// 其他符号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; n &amp;&amp; Character.isDigit(chars[idx])) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = chars[idx] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; (Integer.MAX_VALUE - digit) / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// 本来应该是 ans * 10 + digit &gt; Integer.MAX_VALUE</span></span><br><span class="line">                <span class="comment">// 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。</span></span><br><span class="line">                <span class="keyword">return</span> negative? Integer.MIN_VALUE : Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">10</span> + digit;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="力扣15：三数之和-1"><a href="#力扣15：三数之和-1" class="headerlink" title="力扣15：三数之和"></a>力扣15：三数之和</h2><p>思路<br>标签：数组遍历<br>首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和 nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集<br>如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环<br>如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过<br>当 sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，L++L++<br>当 sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R–R−−<br>时间复杂度：O(n^2)O(n<br>2<br> )，nn 为数组长度<br>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">int</span> L = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210119192846592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode aa = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        aa = aa.next;</span><br><span class="line">        <span class="keyword">int</span> len = getlength(head);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            arr[i] = aa.val;</span><br><span class="line">            aa = aa.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"><span class="comment">//show();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        ListNode min = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        ListNode a = min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            min.val = arr[i];</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(i==len-<span class="number">1</span>)&#123;</span><br><span class="line">                min.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            min = min.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getlength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">/*</span><br><span class="line">1. 事件: 点击事件 onclick</span><br><span class="line">2. 事件要触发函数: changeImg</span><br><span class="line">3. 在函数中</span><br><span class="line">*/</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">changeImg</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//alert(&quot;要切换了&quot;)</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&quot;img1&quot;</span>);<span class="comment">//获取图片名称</span></span></span><br><span class="line"><span class="javascript">img.src = <span class="string">&quot;../img/1-161104143944.gif&quot;</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击切换图片&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;changeImg()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/2.jpg&quot;</span> <span class="attr">id</span>=<span class="string">&quot;img1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="力扣111-二叉树的最小深度"><a href="#力扣111-二叉树的最小深度" class="headerlink" title="力扣111 二叉树的最小深度"></a>力扣111 二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root = [3,9,20,null,null,15,7]<br>输出：2<br>示例 2：</p><p>输入：root = [2,null,3,null,4,null,5,null,6]<br>输出：5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">思路  相同节点的左右节点一个为空 那么该节点深度的最小值 就是为空的那个叶子节点，因为不为空的一定大于为空的深度。</span><br><span class="line">  注释：对应这段代码<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      当两个节点都不为空时，就继续分别寻找左右节点的值 </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_depth = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p><p>返回链表 4-&gt;5.</p><h2 id="剑指offer22-链表中的倒数第K个节点"><a href="#剑指offer22-链表中的倒数第K个节点" class="headerlink" title="剑指offer22 链表中的倒数第K个节点"></a>剑指offer22 链表中的倒数第K个节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode cur = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        <span class="keyword">int</span> len = getsize(head);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len-k;i++)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head;</span><br><span class="line">        <span class="keyword">return</span> cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getsize</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210119150439186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">思路  前面指针和后面指针差距为k  前一个指针到达终点  则后一个指针刚好为要找的倒数第k个节点</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode former = head, latter = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            former = former.next;</span><br><span class="line">        <span class="keyword">while</span>(former != <span class="keyword">null</span>) &#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="剑指offer03-找出数组中重复的数字。"><a href="#剑指offer03-找出数组中重复的数字。" class="headerlink" title="剑指offer03.找出数组中重复的数字。"></a>剑指offer03.找出数组中重复的数字。</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">思路：利用哈希表不能添加重复元素的原理，当送入相同元素时，返回<span class="keyword">null</span>   因此当送入重复元素时，立即<span class="keyword">break</span>或者返回</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> repeat = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/04/18/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E9%9B%86%E9%94%A6/"/>
      <url>2021/04/18/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="创建博客踩坑集锦"><a href="#创建博客踩坑集锦" class="headerlink" title="创建博客踩坑集锦"></a>创建博客踩坑集锦</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1618644474388.png" alt="1618644474388"></p><p>原因：</p><p>这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错</p><p>解决办法:</p><p>git config –global http.sslVerify “false” </p><p>2、<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1618644849204.png" alt="1618644849204"></p><p>创建后乱码</p><p>原因：可能是下载的主题有问题，不在这里浪费时间，直接换一个模板</p><p>解决方案：更换另一个主题模板</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/04/18/Java/"/>
      <url>2021/04/18/Java/</url>
      
        <content type="html"><![CDATA[<p>1、方法的定义格式<br>      修饰符 返回值类型 方法的名字 (参数列表…){<br>           方法的功能主体<br>             循环,判断,变量,比较,运算<br>           return ;<br>      }</p><pre><code> 修饰符:  固定写法  public static 返回值类型:  方法在运算后,结果的数据类型 方法名:  自定义名字,满足标识符规范, 方法名字首字母小写,后面每个单词首字母大写 参数列表: 方法的运算过程中,是否有未知的数据, 如果有未知的数据,定义在参数列表上 (定义变量) return: 方法的返回, 将计算的结果返回. 结束方法</code></pre><p>2、方法定义和使用的注意事项<br>     1. 方法不能定义在另一个方法的里面<br>     2. 写错方法名字<br>     3. 写错了参数列表<br>     4. 方法返回值是void,方法中可以省略return 不写<br>         return 下面不能有代码<br>     5. 方法返回值类型,和return 后面数据类型必须匹配<br>     6. 方法重复定义问题<br>     7. 调用方法的时候,返回值是void, 不能写在输出语句中</p><p>3、方法的重载特性 (overload)<br>    在同一个类中,允许出现同名的方法,只要方法的参数列表不同即可,这样方法就是重载<br>    参数列表不同: 参数的个数,数据类型,顺序<br>4、方法,调用中的参数传递问题<br>     1. 方法参数是基本数据类型<br>     2. 方法参数是引用类型<br>        传递的是内存地址!!!</p><p>5、定义类:<br>      使用类的形式,对现实中的事物进行描述<br>      事物: 方法,属性<br>        方法: 这个事物具备的功能<br>        属性: 变量</p><pre><code> 格式:   public class 类名&#123;        属性定义          修饰符 数据类型 变量名 = 值                方法定义          修饰符 返回值类型  方法名(参数列表)&#123;                        &#125;   &#125;      要求: 使用Java中的类,描述生活中的手机这个事物     手机事物,具备哪些属性, 属于他自己的特性       颜色,品牌, 大小</code></pre><p>1、ArrayList集合的使用<br>   也是<em>引用</em>数据类型<br>   步骤:<br>     1. 导入包 java.util包中<br>     2. 创建引用类型的变量<br>       数据类型&lt; 集合存储的数据类型&gt;  变量名 = new 数据类型 &lt;集合存储的数据类型&gt;  ();<br>       集合存储的数据类型: 要将数据存储到集合的容器中<br>       创建集合引用变量的时候,必须要指定好,存储的类型是什么</p><pre><code>   ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();   3. 变量名.方法   注意: 集合存储的数据,8个基本类型对应8个引用类型 存储引用类型,不存储基本类型    **ArrayList&lt;要存储元素的数据类型&gt; 变量名 = new ArrayList&lt;要存储元素的数据类型&gt;();**</code></pre><p>2、ArrayList 集合中的方法</p><p>   add(参数) 向集合中添加元素,数据存储进去<br>   方法中的参数类型,定义集合对象时候的类型是一致</p><p>   ArrayList<Integer> array = new ArrayList<Integer>();<br>   array.add(3);</p><p>   get(int index) 取出集合中的元素,get方法的参数,写入索引</p><p>   size() 返回集合的长度, 集合存储元素的个数<br>   集合没有length只有size<br>        //在索引2上,添加元素7<br>        array.add(2,7);</p><pre><code>    //将0索引上的元素,修改成10    array.set(0,10);        //将4索引上的元素,删除    array.remove(4);    //清空集合中的元素，集合依然存在    array.clear();</code></pre><p>基本操作：<br>                增删改查</p><h2 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h2><pre><code>                        封装表现：                        1、方法就是一个最基本封装体。                        2、类其实也是一个封装体。                        从以上两点得出结论，封装的好处：                        1、提高了代码的复用性。                        2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这是核心之一，也可以理解为就是封装的概念。                        3、提高了安全性</code></pre><p>this 关键字：<br>    就近访问原则，如果局部内有变量，则使用最近的变量<br>    当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区分局部变量和成员变量<br>    成员变量：类中定义的变量。局部变量：方法中定义的变量，<br>    二者中存在相同的名称时，可以利用this来指定类中的变量<br>    <em>当构造方法中的参数与类中属性同名时，类中属性无法被正确赋值。<br>    这种情况下，可以使用this来指定类中成员，进而用来操作。</em><br>继承：<br>class 子类 extends 父类｛｝<br>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义员工类Employee</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">String name; <span class="comment">// 定义name属性</span></span><br><span class="line"><span class="comment">// 定义员工的工作方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;尽心尽力地工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义研发部员工类Developer 继承 员工类Employee</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义一个打印name的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义测试类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Developer d = <span class="keyword">new</span> Developer(); <span class="comment">// 创建一个研发部员工类对象</span></span><br><span class="line">d.name = <span class="string">&quot;小明&quot;</span>; <span class="comment">// 为该员工类的name属性进行赋值</span></span><br><span class="line">d.printName(); <span class="comment">// 调用该员工的printName()方法</span></span><br><span class="line">d.work(); <span class="comment">// 调用Developer类继承来的work()方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承的好处：<br><em><strong>1、继承的出现提高了代码的复用性，提高软件开发效率。<br>2、继承的出现让类与类之间产生了关系，提供了多态的前提。</strong></em><br>在类的继承中，需要注意一些问题，具体如下：<br>    <em><strong>1、在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。</strong></em><br>class A{}<br>     class B{}<br>     class C extends A,B{}  // C类不可以同时继承A类和B类<br>    <em><strong>2、多个类可以继承一个父类，例如下面这种情况是允许的。</strong></em><br>     class A{}<br>     class B extends A{}<br>     class C extends A{}   // 类B和类C都可以继承类A<br>    <em><strong>3、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。</strong></em><br>     class A{}<br>     class B extends A{}   // 类B继承类A，类B是类A的子类<br>     class C extends B{}   // 类C继承类B，类C是类B的子类，同时也是类A的子类<br>    *** ***<br>1.4    继承-子父类中成员变量的特点<br>了解了继承给我们带来的好处，提高了代码的复用性。继承让类与类或者说对象与对象之间产生了关系。那么，当继承出现后，类的成员之间产生了那些变化呢？<br>类的成员重点学习成员变量、成员方法的变化。<br>成员变量：如果子类父类中出现不同名的成员变量，这时的访问是没有任何问题。<br>看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//Fu中的成员变量。</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//Zi中的成员变量</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//Zi中的成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//访问父类中的num</span></span><br><span class="line">System.out.println(<span class="string">&quot;Fu num=&quot;</span>+num);</span><br><span class="line"><span class="comment">//访问子类中的num2</span></span><br><span class="line">System.out.println(<span class="string">&quot;Zi num2=&quot;</span>+num2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Zi z = <span class="keyword">new</span> Zi(); <span class="comment">//创建子类对象</span></span><br><span class="line">z.show(); <span class="comment">//调用子类中的show方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li> 继承后,子类父类中,成员变量的特点</li><li> Zi extends Fu</li><li></li><li> 子类的对象,调用成员变量</li><li>   <em><strong>子类自己有,使用自己的</strong></em></li><li>   子类没有,调用父类的</li><li></li><li>  在子类中,调用父类的成员,关键字 super.调用父类的成员</li><li>  子类 (派生类)  继承父类  (超类,基类)</li><li></li><li>  this.调用自己本类成员</li><li>  super.调用的自己的父类成员</li><li><strong>当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。</strong>*</li><li><strong>this调用自己本类成员<br>super调用自己的父类成员</strong>*</li></ul><p><em><strong>重写</strong></em></p><ul><li> 继承后,子类父类中成员方法的特点</li><li></li><li>   子类的对象,调用方法的时候</li><li><pre><code> 子类自己有,使用子类</code></pre></li><li><pre><code> 子类自己没有,调用的是父类</code></pre></li><li></li><li>**重载: 方法名一样,参数列表不同,同一个类的事情<pre><code>   重写=覆盖 : Override：子类中,出现了和父类一模一样的方法的时候, 子类重写父类的方法, 覆盖***</code></pre></li></ul><p><em><strong>抽象类的特点</strong></em><br>            1、抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。<br>            2、抽象类不可以直接创建对象，原因：调用抽象方法没有意义。<br>            <strong>3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。<br>            之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。</strong><br><em><strong>抽象类一定是一个父类</strong></em><br>            1、抽象类一定是个父类？<br>                    是的，因为不断抽取而来的。<br>            2、抽象类中是否可以不定义抽象方法。<br>            是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用<br>            3、抽象关键字abstract不可以和哪些关键字共存？<br>                1、private：私有的方法子类是无法继承到的，也不存在覆盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法，而private修饰子类根本无法得到</p><p>package cn.itcast.demo06;<br>/*</p><ul><li> 定义类开发工程师类</li><li>   EE开发工程师 :  工作</li><li>   Android开发工程师 : 工作</li><li></li><li>   根据共性进行抽取,然后形成一个父类Develop</li><li>   定义方法,工作: 怎么工作,具体干什么呀</li><li></li><li><strong>抽象类,不能实例化对象, 不能new的<br>不能创建对象的原因:  如果真的让你new了, 对象.调用抽象方法,抽象方法没有主体,根本就不能运行<br>抽象类使用: 定义类继承抽象类,将抽象方法进行重写,创建子类的对象</strong>*</li></ul><p><em>public abstract class Develop {</em><br>   //定义方法工作方法,但是怎么工作,说不清楚了,讲不明白<br>    //就不说, 方法没有主体的方法,必须使用关键字abstract修饰<br>    //抽象的方法,必须存在于抽象的类中,类也必须用abstract修饰<br>    public abstract void work();<br>}<br>抽象类的意思是：抽象类的子类都有这个功能，例如work，但你要调用这个work子类的时候，一定要进行覆盖，重写</p><ul><li>  抽象类,可以没有抽象方法,可以定义带有方法体的方法</li><li>  让子类继承后,可以直接使用</li><li>// private abstract void show();<br>  //抽象方法,需要子类重写, 如果父类方法是私有的,子类继承不了,也就没有了重写</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>1、接口定义：<br>    与定义类的class不同，接口定义时需要使用interface关键字。<br>定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。这点可以让我们将接口看做是一种只包含了功能声明的特殊类。<br>定义格式：<br>public interface 接口名 {<br>抽象方法1;<br>抽象方法2;<br>抽象方法3;<br>}<br>使用interface代替了原来的class，其他步骤与定义类相同：<br><em><strong>    接口中的方法均为公共访问的抽象方法<br>    接口中无法定义普通的成员变量</strong></em><br>                    /*<br>                     * 定义接口<br>                     *   使用关键字interface  接口名字<br>                     * 接口定义:<br>                     *    成员方法,全抽象<br>                     *    不能定义带有方法体的方法<br>                     *<br>                     * 定义抽象方法: <strong>固定格式</strong><br>                     *<br>                     *   <strong>public abstract 返回值类型  方法名字(参数列表);<br>                     *   修饰符 public  写,或者不写,都是public</strong><br>                     *<br>                     *  接口中成员变量的定义<br>                     *    成员变量的定义,具体要求<br>                     *<br>                     *    要求 : <strong>必须定义为常量</strong><br>                     *    固定格式:<br>                     *      public static final 数据类型 变量名 = 值<br>                     */<br>类与接口的关系为实现关系，即类实现接口。实现的动作类似继承，只是关键字不同，实现使用implements。</p><p><em><strong>接口中成员的特点</strong></em></p><ul><li>   <em><strong>1. 成员变量的特点, 没有变量,都是常量</strong></em></li><li>   固定定义格式: public static final 数据类型 变量名 = 值</li><li><strong>public  权限<br>static  可以被类名直接.调用<br>final   最终,固定住变量的值</strong>*</li><li>// </li><li>注意: public static final 修饰符,在接口的定义中,可以省略不写</li><li>   但是,！！！不写不等于没有，即便是int x = 3 他仍然不可修改</li><li>   三个修饰符,还可以选择性书写</li><li></li><li><ol start="2"><li>接口中的成员方法特点:</li></ol></li><li><pre><code> public abstract 返回值类型 方法名(参数列表)</code></pre></li><li><pre><code> 修饰符  public abstract 可以不写,选择性书写</code></pre></li><li><pre><code> 但是,写不写,都有</code></pre></li><li></li><li><ol start="3"><li>实现类,实现接口,重写接口全部抽象方法,创建实现类对象</li></ol></li><li><pre><code> 实现类,重写了一部分抽象方法,实现类,还是一个抽象类</code></pre></li><li>/<br> class + MyInterfaceImp1 + implements + MyInterface<br> class               类                      实现               接口</li></ul><p>定义类, 实现接口,重写接口中的抽象方法<br>创建实现类的对象<br>类实现接口, 可以理解为继承<br>关键字  implements</p><ul><li>  class 类 implements 接口{</li><li><pre><code>重写接口中的抽象方法</code></pre></li><li>  }</li><li><pre><code>                   类                   实现                     接口</code></pre></li><li>  class  MyInterfaceImpl    implements         MyInterface</li></ul><p><em><strong>接口的多实现：</strong></em><br>多实现没有安全隐患，原因在于接口中的方法全是抽象，没有主体 </p><ul><li>  类C,同时去实现2个接口,接口A,B</li><li>  作为实现类,C,<em><strong>全部重写</strong></em>两个接口的所有抽象方法,才能建立C类的对象</li><li></li><li>**   C类,在继承一个类的同时,可以实现多个接口***<pre><code>   必须同时对继承的抽象类、接口中的抽象方法都要进行重写，才能够运行</code></pre></li></ul><h2 id="接口之间的多继承"><a href="#接口之间的多继承" class="headerlink" title="接口之间的多继承"></a>接口之间的多继承</h2><p>day11: demo04</p><p><em><strong>一个接口可以继承多个接口</strong></em><br>/*</p><ul><li>  实现接口C,重写C接口的全部抽象方法</li><li>  而且接口C,继承A,B</li><li>  D实现类,重写A,B,C三接口全部抽象方法</li><li></li><li>  问: Java中有多继承吗</li><li>   类没有多继承</li><li>   接口之间多继承</li><li>/</li></ul><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p>相同点:<br>    都位于继承的顶端,用于被其他类实现或继承;<br>    都不能直接实例化对象;<br>    都包含抽象方法,其子类都必须覆写这些抽象方法;<br>区别:<br>    抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;<br>    一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)<br>    抽象类是这个事物中应该具备的你内容, 继承体系是一种 is..a关系<br>    接口是这个事物中的额外内容,继承体系是一种 like..a关系</p><p>二者的选用:<br>    优先选用接口,尽量少用抽象类;<br>    需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;</p><h2 id="多态性-day11demo5"><a href="#多态性-day11demo5" class="headerlink" title="多态性:day11demo5"></a>多态性:day11demo5</h2><p><a href="https://bbs.csdn.net/topics/392556362?utm_medium=distribute.pc_relevant.none-task-discussion_topic-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-discussion_topic-BlogCommendFromBaidu-1.control">下面的文字抄的</a><br>多态性是对象多种表现形式的体现。</p><p>现实中，比如我们按下 F1 键这个动作：<br>如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；<br>如果当前在 Word 下弹出的就是 Word 帮助；<br>在 Windows 下弹出的就是 Windows 帮助和支持。<br>同一个事件发生在不同的对象上会产生不同的结果。<br>多态的优点</p><ol><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性<br>多态存在的三个必要条件</li></ol><p>继承<br>重写<br>父类引用指向子类对象<br>比如：</p><p>Parent p = new Child();<br>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p><p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><p>以下是一个多态实例的演示，详细说明请看注释：</p><p>Test.java 文件代码：<br>public class Test {<br>    public static void main(String[] args) {<br>      show(new Cat());  // 以 Cat 对象调用 show 方法<br>      show(new Dog());  // 以 Dog 对象调用 show 方法</p><pre><code>  Animal a = new Cat();  // 向上转型    a.eat();               // 调用的是 Cat 的 eat  Cat c = (Cat)a;        // 向下转型    c.work();        // 调用的是 Cat 的 work</code></pre><p>  }<br><em><strong>从这之上是抄的</strong></em></p><p> <strong>Java实现多态有三个必要条件：继承、重写、向上转型。</strong><br>// 多态调用方法,方法必须运行子类的重写!!</p><pre><code>    //Java中,对象的多态性,调用程序中的方法    // 公式:  父类类型或者是接口类型   变量  = new 子类的对象();                                                                                                                                                                         </code></pre><p>Fu f = new Zi();<br>package cn.itcast.demo05;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 多态调用方法,方法必须运行子类的重写!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Java中,对象的多态性,调用程序中的方法</span></span><br><span class="line"><span class="comment">// 公式:  父类类型或者是接口类型   变量  = new 子类的对象();</span></span><br><span class="line">Fu  f  = <span class="keyword">new</span> Zi();</span><br><span class="line">f.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类Animal,子类是Cat</span></span><br><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">a.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口Smoking,实现类Student</span></span><br><span class="line">Smoking sk = <span class="keyword">new</span> Student();</span><br><span class="line">sk.smoking();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  多态中,成员特点</li><li>  Fu f = new Zi();</li><li><pre><code> f.a成员变量对应的是父类中的成员变量</code></pre></li><li>  <em><strong>成员变量:</strong></em> </li><li><pre><code>***编译的时候, 参考父类中有没有这个变量,如果有,编译成功,没有编译失败***</code></pre></li><li><pre><code>***运行的时候, 运行的是父类中的变量值***</code></pre></li><li>   <em><strong>编译运行全看父类</strong></em></li><li></li><li>  <em><strong>成员方法:</strong></em></li><li>f.show()需要在父类中有这个show方法，父类没有编译失败，如果子类有则运行子类的方法，如果子类没有这个show方法，则运行父类的方法，如果父类没有show方法，那么就报错了</li><li><pre><code>***编译的时候, 参考父类中有没有这个方法,如果有,编译成功,没有编译失败***</code></pre></li><li><pre><code>***运行的时候, 运行的是子类的重写方法***</code></pre></li><li></li><li>   <em><strong>编译看父类,运行看子类</strong></em></li><li>注意：要看清是多态还是子类</li><li>多态：    Fu a = new Zi();</li><li>子类：    Zi  a = new Zi();这个是子类，完全可以在父类中没有show方法的条件下运行show(子类有)</li></ul><p>关键字：Instanceof，</p><ul><li> 运算符比较运算符, 结果真假值</li><li> 关键字, instanceof, 比较引用数据类型</li><li><pre><code> Person p = new Student();</code></pre></li><li>  p  = new Teacher() //Person p = new Teacher()这种方法则重复定义错误</li><li>  上边先将p定义成学生，再将其定义为老师，最后p是老师类，经过instanceof判断是否为学生类时，则返回false            </li><li></li><li>  关键字 instanceof 比较, 一个引用类型的变量,是不是这个类型的对象</li><li>   p变量,是Student类型对象,还是Teacher类型对象</li><li></li><li>   引用变量 instanceof 类名</li><li>   p instanceof Student  比较,p是不是Student类型的对象,如果是,intanceof返回true</li><li></li><li><strong>多态中的转型*</strong><br>Fu f = new Zi();<br>       向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，<em><strong>多态本身就是向上转型的过程。</strong></em><br>   父类类型  变量名 = new 子类类型();<br>   如：Person p = new Student();<br>       向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！<br>   子类类型 变量名 = (子类类型) 父类类型的变量;<br>   如:Student stu = (Student) p;  //变量p 实际上指向Student对象<br>   package cn.itcast.demo08;<br>/*<ul><li> 测试类</li><li><ol><li>实现动物和Cat,Dog多态调用</li></ol></li><li><ol start="2"><li>做类型的强制转换,调用子类的特有功能</li></ol></li><li>/</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//两个子类,使用两次多态调用</span></span><br><span class="line">Animal a1 = <span class="keyword">new</span> Cat();</span><br><span class="line">Animal a2 = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">//a1,a2调用子类父类共有方法,运行走子类的重写</span></span><br><span class="line">a1.eat();</span><br><span class="line">a2.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型向下转型,强制转换,调用子类的特有</span></span><br><span class="line"><span class="comment">//防止发生异常: a1属于Cat对象,转成Cat类,  a2属于Dog对象,转成Dog</span></span><br><span class="line"><span class="comment">//instanceof判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a1 <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">Cat c = (Cat)a1;</span><br><span class="line">c.catchMouse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a2 <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">Dog d = (Dog)a2;</span><br><span class="line">d.lookHome();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>&#125;</code></pre><p>}</p><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><p>示例：<em><strong>Person p = new Person(“张三”,20);</strong></em><br>定义类必须拥有构造方法，构造方法不写也有<br>与类同名的方法，可以在定义对象时进行参数传递<br>    自定义的Person类，成员变量，name，age<br>    要求在new Person的同时，就制定好name，age的值<br>    实现功能，利用方法去实现，构造方法，构造器Constructor<br>    作用：在new的同时对成员变量赋值，给对象的属性初始化赋值new Person 对属性name，age赋值</p><ul><li> 构造方法的定义格式</li><li>   权限  方法名(参数列表){</li><li>   }</li><li>   方法的名字,必须和类的名字完全一致</li><li>   构造方法不允许写返回值类型  , void 也不能写</li><li></li><li>   构造方法在什么时候,运行呢, 在new 的时候,自动执行</li><li>   只运行一次,仅此而已</li><li></li><li>   每个class必须拥有构造方法,构造方法不写也有</li><li>   编译的时候,javac, 会自动检查类中是否有构造方法</li><li>   如果有,就这样的</li><li>   如果没有,编译器就会自动添加一个构造方法</li><li><pre><code> 编译器自动添加的构造方法: public Person()&#123;&#125;</code></pre></li><li>自己手写了构造方法,编译的时候,不会自动添加构造方法!<br>     构造方法的细节：<br>1、<em><strong>一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的</strong></em><br>2、构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。<h2 id="this关键字在构造方法之间调用"><a href="#this关键字在构造方法之间调用" class="headerlink" title="this关键字在构造方法之间调用"></a>this关键字在构造方法之间调用</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo03;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   this可以在构造方法之间进行调用</span></span><br><span class="line"><span class="comment"> *   this.的方式,区分局部变量和成员变量同名情况</span></span><br><span class="line"><span class="comment"> *   this在构造方法之间的调用,语法 this()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//调用了有参数的构造方法</span></span><br><span class="line"><span class="comment">//参数李四,20传递给了变量name,age</span></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  构造方法,传递String,int</span></span><br><span class="line"><span class="comment"> *  在创建对象的同时为成员变量赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默认的隐式super();语句<br>格式：<br>    调用本类中的构造方法<br>    this(实参列表);<br>    调用父类中的空参数构造方法<br>    super();<br>    调用父类中的有参数构造方法<br>        super(实参列表);</p><p><em><strong>子类中,super()的方式,调用父类的构造方法</strong></em>day12 demo04</p><ul><li><p> super()调用的是父类的空参数构造</p></li><li><p> super(参数) 调用的是父类的有参数构造方法</p></li><li></li><li><p> 子类的构造方法, 有一个默认添加的构造方法</p></li><li><p> 注意: 子类构造方法的第一行,有一个隐式代码 super()</p></li><li><pre><code>      public Student()&#123;</code></pre></li><li><pre><code>          super();</code></pre></li><li><pre><code>       &#125;</code></pre></li><li><p>  子类的构造方法第一行super语句,调用父类的构造方法</p></li><li><p>/</p></li><li><p><strong>子类构造方法的报错原因:找不到父类的空参数构造器</strong>*</p></li><li><p> 子类中,没有手写构造,编译器添加默认的空参数</p></li><li><p> public Student(){</p></li><li><pre><code>super();</code></pre></li><li><p> }</p></li><li><p> 编译成功,必须手动编写构造方法,请你在super中加入参数</p></li><li></li><li><p> 注意: 子类中所有的构造方法,无论重载多少个,第一行必须是super()</p></li><li><p> 如果父类有多个构造方法,子类任意调用一个就可以</p></li><li><p>super()语句必须是构造方法第一行代码</p><pre><code> 构造方法第一行,写this()还是super()  不能同时存在,任选其一,  ***保证子类的所有构造方法调用到父类的构造方法即可***</code></pre><p>  <em><strong>小结论: 无论如何,子类的所有构造方法,直接,间接必须调用到父类构造方法</strong></em><br>  子类的构造方法,什么都不写,默认的构造方法第一行 super();<br>package cn.itcast.demo07;<br>/*</p></li><li><p> Student类和Worker有相同成员变量,name age</p></li><li><p> 继承的思想,共性抽取,形成父类</p></li><li><p> Person,抽取出来父类</p></li><li><p> 成员变量,私有修饰</p></li><li><p> 同时需要在创建学生和工人对象就必须明确姓名和年龄</p></li><li><p> new Student, new Worker 姓名,年龄明确了</p></li><li><p>/</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">代码<span class="number">2</span></span><br><span class="line"><span class="keyword">package</span> cn.itcast.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码<span class="number">3</span></span><br><span class="line"><span class="keyword">package</span> cn.itcast.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建工人对象, Worker,指定姓名年龄</span></span><br><span class="line">Worker w = <span class="keyword">new</span> Worker(<span class="string">&quot;光头强&quot;</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(w.getName());</span><br><span class="line">System.out.println(w.getAge());</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建学生对象, Student,指定姓名年龄</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student(<span class="string">&quot;肥波&quot;</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(s.getName());</span><br><span class="line">System.out.println(s.getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><em><strong>final的概念：</strong></em><br>        继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？<br>        要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。<br>    在类的定义上,加上修饰符,final<br>         *  <strong>类: 最终类, 不能有子类,不可以被继承</strong><br>         *  <strong>但是使用方式,没有变化,创建对象,调用方法</strong></p><p>final的特点：<br>1、final修饰类不可以被继承，但是可以继承其他类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yy</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> <span class="keyword">extends</span> <span class="title">Yy</span></span>&#123;&#125; <span class="comment">//可以继承Yy类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;&#125; <span class="comment">//不能继承Fu类</span></span><br></pre></td></tr></table></figure><p>2、final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="comment">// final修饰的方法，不可以被覆盖，但可以继承使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="comment">//重写method2方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、final修饰的变量称为常量，这些变量只能赋值一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">i = <span class="number">30</span>; <span class="comment">//赋值报错，final修饰的变量只能赋值一次</span></span><br></pre></td></tr></table></figure><p>4、引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">p = p2; <span class="comment">//final修饰的变量p，所记录的地址值不能改变</span></span><br><span class="line">p.name = <span class="string">&quot;小明&quot;</span>;<span class="comment">//可以更改p对象中name属性值</span></span><br></pre></td></tr></table></figure><p>5、修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="comment">//直接赋值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final修饰的成员变量，需要在创建对象前赋值，否则报错。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> n; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//可以在创建对象时所调用的构造方法中，为变量n赋值</span></span><br><span class="line">n = <span class="number">2016</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itast.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">z.function();</span><br><span class="line">z.show();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">10</span>;<span class="comment">//被final修饰,一次赋值,终身不变</span></span><br><span class="line">System.out.println(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//final修饰引用变量问题</span></span><br><span class="line"><span class="comment">//变量,保存内存地址,终身不变  </span></span><br><span class="line"><span class="keyword">final</span> Zi z2 = <span class="keyword">new</span> Zi();</span><br><span class="line">z2.function();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论final修饰基本类型还是引用类型，一旦final后，终身不能改变。</p><p>final修饰成员变量<br>成员变量，在堆内存，具有默认值<br>final修饰的成员变量，固定的不是内存的默认值<br>固定的是，成员变量的手动赋值，绝对不是内存的默认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> age;<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">10</span>;<span class="comment">//正确写法</span></span><br></pre></td></tr></table></figure><p>成员变量的赋值，2种实现方式，<br><strong>法一：是定义的时候，直接=赋值。<br>   法二：是赋值方式，采用构造方法赋值</strong><br>    保证：被final修饰的成员变量，只能被赋值一次<br>    final int n;<br>        n = 100;  //这样也是错误，<strong>如果一开始没有定义初值，那么只能通过方法赋值。setAge方法也不行<br>        ，因为setAge是在建立对象之后的操作，final必须在建立对象时进行定义</strong><br>    成员变量，需要在创建对象前赋值，否则报错<br>    构造方法，是创建对象中的事情，可以为成员</p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>1、static概念：<br>        当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？<br>        可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。<br>2、static特点：<br><strong>（1）被static修饰的成员变量属于类，不属于这个类的某个对象。</strong>（也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(Person.className);</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">&quot;哈哈&quot;</span>;</span><br><span class="line">p2.name = <span class="string">&quot;嘻嘻&quot;</span>;</span><br><span class="line">System.out.println(p1.name);</span><br><span class="line">System.out.println(p2.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象调用类的静态成员变量</span></span><br><span class="line">p1.className = <span class="string">&quot;基础班&quot;</span>;</span><br><span class="line">System.out.println(p2.className);</span><br><span class="line"><span class="comment">//className是静态的，定义一次之后，无论谁调用都是一个东西</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）被static修饰的成员<em>可以并且建议</em>通过类名直接访问。</strong>通过类名访问<br>    <strong>访问静态成员的格式：<br>    类名.静态成员变量名<br>    类名.静态成员方法名(参数)</strong><br>    对象名.静态成员变量名         ——不建议使用该方式，会出现警告<br>    对象名.静态成员方法名(参数)     ——不建议使用该方式，会出现警告<br>2.3    static注意事项<br>（1）静态内容是优先于对象存在，只能访问静态，不能使用this/super。静态修饰的内容存于静态区。<br>（2）同一个类中，静态成员只能访问静态成员<br>（3）main方法为静态方法仅仅为程序执行入口，它不属于任何一个对象，可以定义在任意类中。<br>2.4    定义静态常量<br>    开发中，我们想在类中定义一个静态常量，通常使用public static final修饰的变量来完成定义。此时变量名用全部大写，多个单词使用下划线连接。<br>定义格式：<br>    public static final 数据类型 变量名 = 值;</p><p>方法里面如果都是静态变量，方法也应该加静态<br>如果方法里面存在静态和非静态，那么方法不应该加静态</p><p>静态的注意事项<br><strong>在静态中不能调用非静态</strong><br>为什么呢? 为什么静态不能调用非静态,生命周期<br><strong>静态优先于非静态存在于内存中</strong><br>静态 前人 先人   非静态 后人</p><p><strong>静态不能写this,不能写super</strong><br>问题:  static 修饰到底什么时候使用,应用场景<br>static 修饰成员变量,成员方法<br>成员变量加static, 根据具体事物,具体分析问题<br>定义事物的时候,多个事物之间是否有共性的数据!!<br>请你将共性的数据定义为静态的成员变量</p><p><strong>成员方法加static, 跟着变量走<br>如果方法,没有调用过非静态成员,将方法定义为静态</strong><br>每调用过非静态成员，则都定义为静态</p><p>多态调用中,编译看谁,运行看谁<br>编译都看 = 左边的父类, 父类有编译成功,父类没有编译失败<br>     <em><strong>运行,静态方法, 运行父类中的静态方法（先执行父类，所以父类先定义了静态方法）<br>     运行,非静态方法,运行子类的重写方法</strong></em><br>     成员变量,编译运行全是父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();   <span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println(f.i);</span></span><br><span class="line"><span class="comment">//调用还是父类的静态方法,原因: 静态属于类,不属于对象     </span></span><br><span class="line"><span class="comment">//对象的多态性,静态和对象无关,父类的引用.静态方法</span></span><br><span class="line">f.show();</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itast.demo03;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   定义Person类,</span></span><br><span class="line"><span class="comment"> *   定义对象的特有数据,和对象的共享数据</span></span><br><span class="line"><span class="comment"> *   对象的特有数据(非静态修饰) 调用者只能是 new 对象</span></span><br><span class="line"><span class="comment"> *   对象的共享数据(静态修饰)  调用者可以是new 对象,可以是类名</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *   被静态修饰的成员,可以被类名字直接调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String className;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itast.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> age ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span> sex;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(name+age);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a+b+c;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(sex);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(name+age);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itast.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(Person.className);</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">&quot;哈哈&quot;</span>;</span><br><span class="line">p2.name = <span class="string">&quot;嘻嘻&quot;</span>;</span><br><span class="line">System.out.println(p1.name);</span><br><span class="line">System.out.println(p2.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象调用类的静态成员变量</span></span><br><span class="line">p1.className = <span class="string">&quot;基础班&quot;</span>;</span><br><span class="line">System.out.println(p2.className);</span><br><span class="line"><span class="comment">//className是静态的，定义一次之后，无论谁调用都是一个东西</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.1    内部类概念<br>（1）什么是内部类<br>将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。<br>（2）什么时候使用内部类<br>在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，<em><strong>汽车</strong></em>中还包含这发动机，这时<em><strong>发动机</strong></em>就可以使用<em><strong>内部类</strong></em>来描述。</p><ul><li>  内部类的定义</li><li><pre><code>将内部类,定义在了外部的成员位置</code></pre></li><li>  类名Outer,内部类名Inner</li><li></li><li>  成员内部类,可以使用成员修饰符,public static ….</li><li>  也是个类,可以继承,可以实现接口</li><li></li><li>  调用规则: 内部类,可以使用外部类成员,包括私有</li><li>  外部类要使用内部类的成员,必须建立内部类对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//外部类成员位置,定义内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;内部类方法inner &quot;</span>+a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 汽车 </span>&#123; <span class="comment">//外部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 发动机 </span>&#123; <span class="comment">//内部类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）内部类的分类<br><strong>内部类</strong>分为<strong>成员内部类</strong>与<strong>局部内部类</strong>。<br>我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。<strong>在内部类中可以直接访问外部类的所有成员。</strong><br><strong>4.2    成员内部类</strong>  在成员变量位置的内部类<br><em><strong>成员内部类，定义在外部类中的成员位置</strong></em>。与类中的成员变量相似，<em>可通过外部类对象进行访问</em><br>（1）定义格式<br>class 外部类 {<br>    修饰符 class 内部类 {<br>        //其他代码<br>}<br>}<br>（2）访问方式<br>外部类名.内部类名 变量名 = new 外部类名().new 内部类名();</p><p>（3）成员内部类代码演示<br>定义类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;<span class="comment">//外部类，身体</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> life= <span class="keyword">true</span>; <span class="comment">//生命状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123; <span class="comment">//内部类，心脏</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;心脏噗通噗通的跳&quot;</span>)</span><br><span class="line"> System.out.println(<span class="string">&quot;生命状态&quot;</span> + life); <span class="comment">//访问外部类成员变量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建内部类对象</span></span><br><span class="line">Body.Heart bh = <span class="keyword">new</span> Body().<span class="function">new <span class="title">Heart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//调用内部类中的方法</span></span><br><span class="line">bh.jump();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.3    局部内部类</strong>：在方法中的内部类<br><em><strong>局部内部类，定义在外部类方法中的局部位置</strong></em>。<em><strong>与访问方法中的局部变量相似，可通过调用方法进行访问</strong></em><br>（1）定义格式<br>            class 外部类 {<br>                    修饰符 返回值类型 方法名(参数) {<br>                            class 内部类 {<br>                            //其他代码<br>                            }<br>                    }<br>            }</p><p>（2）局部内部类代码演示<br>    定义类</p><p><em>好的例子：</em>重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Party</span> </span>&#123;<span class="comment">//外部类，聚会</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">puffBall</span><span class="params">()</span></span>&#123;<span class="comment">// 吹气球方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> </span>&#123;<span class="comment">// 内部类，气球</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">puff</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;气球膨胀了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建内部类对象，调用puff方法</span></span><br><span class="line"><span class="keyword">new</span> Ball().puff();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>访问内部类    public static void main(String[] args) &#123;        //创建外部类对象            Party p = new Party();            //调用外部类中的puffBall方法            p.puffBall();    &#125;</code></pre><p>4.4 内部类的实际使用–匿名内部类<br>1.匿名内部类概念<br>    最常用到的内部类就是匿名内部类，它是局部内部类的一种。<br>定义的匿名内部类有两个含义：<br>            （1）临时定义某一指定类型的子类<br>            （2）定义后即刻创建刚刚定义的这个子类的对象</p><p>2.定义匿名内部类的作用与格式<br>    作用：匿名内部类是创建某个类型子类对象的快捷方式。<br>    格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类或接口()&#123;</span><br><span class="line"><span class="comment">//进行方法重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已经存在的父类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量</span></span><br><span class="line">Person  p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“我吃了”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用eat方法</span></span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure><p>使用匿名对象的方式，将定义子类与创建子类对象两个步骤由一个格式一次完成，。虽然是两个步骤，但是两个步骤是连在一起完成的。<br>匿名内部类如果不定义变量引用，则也是匿名对象。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“我吃了”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.eat();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  实现类,实现接口 重写接口抽象方法,创建实现类对象</span></span><br><span class="line"><span class="comment"> *  class XXX implements Smoking&#123;</span></span><br><span class="line"><span class="comment"> *      public void smoking()&#123;</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> *  XXX x = new XXX();</span></span><br><span class="line"><span class="comment"> *  x.smoking(); </span></span><br><span class="line"><span class="comment"> *  Smoking s = new XXX();</span></span><br><span class="line"><span class="comment"> *  s.smoking();</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  匿名内部类,简化问题:  定义实现类,重写方法,建立实现类对象,合为一步完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> Smoking()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;人在吸烟&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.smoking();</span><br><span class="line">注释中的实现类和匿名内部类实现的功能一致</span><br></pre></td></tr></table></figure><p>package cn.itast.demo09;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用匿名内部类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义实现类,重写方法,创建实现类对象,一步搞定</span></span><br><span class="line"><span class="comment"> *  格式:</span></span><br><span class="line"><span class="comment"> *    new 接口或者父类()&#123;</span></span><br><span class="line"><span class="comment"> *       重写抽象方法</span></span><br><span class="line"><span class="comment"> *    &#125;;</span></span><br><span class="line"><span class="comment"> *    从 new开始,到分号结束</span></span><br><span class="line"><span class="comment"> *    创建了接口的实现类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> Smoking()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;人在吸烟&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.smoking();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、包的声明与访问"><a href="#5、包的声明与访问" class="headerlink" title="5、包的声明与访问"></a>5、包的声明与访问</h2><p>5.1 包的概念<br>        java的包，其实就是我们电脑系统中的文件夹，包里存放的是类文件。<br>        当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为分包管理。<br>        在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是以包作为边界。<br>        类中声明的包必须与实际class文件所在的文件夹情况相一致，即类声明在a包下，则生成的.class文件必须在a文件夹下，否则，程序运行时会找不到类。<br>5.2 包的声明格式<br>        通常使用公司网址反写，可以有多层包，包名采用全部小写字母，多层包之间用”.”连接<br>    类中包的声明格式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名.包名.包名…;</span><br></pre></td></tr></table></figure><pre><code>如：黑马程序员网址itheima.com那么网址反写就为com.itheima    传智播客 itcast.cn  那么网址反写就为 cn.itcast</code></pre><p>    注意：声明包的语句，必须写在程序有效代码的第一行（注释不算）<br>    代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast; <span class="comment">//包的声明，必须在有效代码的第一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>5.3    包的访问<br>在访问类时，为了能够找到该类，必须使用含有包名的类全名（包名.类名）。</p><p>包名.包名….类名<br>如： java.util.Scanner<br>     java.util.Random<br>    cn.itcast.Demo<br><em><strong>带有包的类，创建对象格式：包名.类名 变量名 = new包名.类名();</strong></em><br>     cn.itcast.Demo d = new cn.itcast.Demo();</p><p>1、前提：包的访问与访问权限密切相关，这里以一般情况来说，即类用public修饰的情况。</p><p>2、类的简化访问<br>        <strong>当我们要使用一个类时，这个类与当前程序在同一个包中（即同一个文件夹中），或者这个类是java.lang包中的类时通常可以省略掉包名，直接使用该类。</strong><br>        如：cn.itcast包中有两个类，PersonTest类，与Person类。我们在PersonTest类中，访问Person类时，由于是同一个包下，访问时可以省略包名，即直接通过类名访问 Person。<br>5.4    import导包<br>我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。<br>可以通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。<br>导包的格式：<br>import 包名.类名;</p><pre><code>当程序导入指定的包后，使用类时，就可以简化了。演示如下</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入包前的方式</span></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">java.util.Random r1 = <span class="keyword">new</span> java.util.Random();</span><br><span class="line">java.util.Random r2 = <span class="keyword">new</span> java.util.Random();</span><br><span class="line">java.util.Scanner sc1 = <span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line">java.util.Scanner sc2 = <span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入包后的方式</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">Random r1 = <span class="keyword">new</span> Random();</span><br><span class="line">Random r2 = <span class="keyword">new</span> Random();</span><br><span class="line">Scanner sc1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">Scanner sc2 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>    import导包代码书写的位置：在声明包package后，定义所有类class前，使用导包import包名.包名.类名;</p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，以下表来说明不同权限的访问能力：<br><img src="https://img-blog.csdnimg.cn/20201126202628348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>权限：<br>default：本包和自己能用，子类不能用<br><strong>private</strong>：本类中访问（常用）<br>protected：本包中与其他包中的子类可以访问<br><strong>public</strong>：所有包中的所有类都可以访问使用public（常用）</p><h2 id="7、代码块"><a href="#7、代码块" class="headerlink" title="7、代码块"></a>7、代码块</h2><p>7.1    局部代码块<br>局部代码块是定义在方法或语句中<br>特点：<br>    1、以”{}”划定的代码区域，此时只需要关注作用域的不同即可<br>    2、方法和类都是以代码块的方式划定边界的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">          <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">         System.out.println(<span class="string">&quot;普通代码块&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">99</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;代码块之外&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.2    构造代码块<br>构造代码块是定义在类中成员位置的代码块<br>特点：<br>    1、<strong>优先于构造方法执行</strong>，构造代码块用于执行所有对象均需要的初始化动作<br>    2、每创建一个对象均会执行一次构造代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//构造代码块</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造代码块执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Person无参数的构造函数执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="string">&quot;Person（age）参数的构造函数执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.3    静态代码块<br>静态代码块是定义在成员位置，使用static修饰的代码块。<br>特点：<br>    1、它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。<br>    2、该类不管创建多少对象，静态代码块只执行一次。<br>    3、可用于给静态变量赋值，用来给类进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itast.demo12;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  静态代码块, 只执行一次</span></span><br><span class="line"><span class="comment"> *  构造代码块,new一次,就执行一次,优先于构造方法</span></span><br><span class="line"><span class="comment"> *  构造方法, new 一次,就执行一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  System.out.println(<span class="string">&quot;我是构造方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构造代码块</span></span><br><span class="line">  &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;我是构造代码块&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//静态代码块</span></span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;我是静态代码块&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="keyword">package</span> cn.itast.demo12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">&quot;张三2&quot;</span>,<span class="number">220</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果:<br>            我是静态代码块<br>            我是构造代码块<br>            我是构造方法<br>            我是构造代码块<br>            我是构造方法</p><ul><li> 静态代码块, 只执行一次</li><li> 构造代码块,new一次,就执行一次,优先于构造方法</li><li> 构造方法, new 一次,就执行一次</li></ul><h2 id="第2章-面向对象"><a href="#第2章-面向对象" class="headerlink" title="第2章 面向对象"></a>第2章 面向对象</h2><p>2.1    不同修饰符使用细节<br>常用来修饰类、方法、变量的修饰符如下：<br>    public 权限修饰符，公共访问, 类,方法,成员变量<br>    protected 权限修饰符，受保护访问, 方法,成员变量<br>    默认什么也不写 也是一种权限修饰符，默认访问, 类,方法,成员变量<br>    private 权限修饰符，私有访问, 方法,成员变量<br>    static 静态修饰符  方法,成员变量<br>    final 最终修饰符   类,方法,成员变量,局部变量<br>    abstract 抽象修饰符  类 ,方法</p><p>我们编写程序时，权限修饰符一般放于所有修饰符之前，不同的权限修饰符不能同时使用；<br><strong>同时，abstract与private不能同时使用；<em>abstract类必须重写，而private、static、final存在限制</em><br>同时，abstract与static不能同时使用；<br>同时，abstract与final不能同时使用。</strong></p><p>public static void main(String[] args) {<br>        //调用方法operatorPerson,传递Person类型对象<br>        Person p = new Person();<br>        operatorPerson(p);</p><pre><code>    operatorPerson(new Person());&#125;</code></pre><p>修饰类能够使用的修饰符：<br><strong>修饰类只能使用public、默认的、final、abstract关键字<br>使用最多的是 public关键字</strong><br>        public class Demo {} <strong>//最常用的方式</strong><br>        class Demo2{}<br>        public final class Demo3{}<br>        public abstract class Demo4{}</p><p>    修饰<strong>成员变量</strong>能够使用的修饰符：<br>        public : 公共的<br>        protected : 受保护的<br>            : 默认的<br>        private ：私有的<br>        final : 最终的<br>        static : 静态的<br><strong>修饰成员变量使用最多的是 private</strong><br>        public int count = 100;<br>        protected int count2 = 100;<br>        int count3 = 100;<br>        private int count4 = 100; <strong>//最常用的方式</strong><br>        public final int count5 = 100;<br>        public static int count6 = 100;<br>    <strong>修饰构造方法</strong>能够使用的修饰符：<br>        public : 公共的<br>        protected : 受保护的<br>            : 默认的<br>        private ：私有的<br>        使用最多的是 public<br>        public Demo(){} //最常用的方式<br>        protected Demo(){}<br>        Demo(){}<br>        private Demo(){}<br>    修饰成员方法能够使用的修饰符：<br>        public : 公共的<br>        protected : 受保护的<br>            : 默认的<br>        private ：私有的<br>        final : 最终的<br>        static : 静态的<br>        abstract : 抽象的<br>        使用最多的是 public</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//最常用的方式</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//最常用的方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span></span>;<span class="comment">//最常用的方式</span></span><br></pre></td></tr></table></figure><h2 id="自定义数据类型的使用"><a href="#自定义数据类型的使用" class="headerlink" title="自定义数据类型的使用"></a>自定义数据类型的使用</h2><p><strong>3.1    辨析成员变量与方法参数的设计定义</strong><br>    定义长方形类，包含求周长与求面积的方法<br>    定义数学工具类，包含求两个数和的二倍与求两个数积的方法<br>思考：这两个类的计算方法均需要两个数参与计算，请问两个数定义在成员位置还是形参位置更好，为什么？<br>如果变量是该类的一部分时，定义成成员变量。<br>如果变量不应该是类的一部分，而仅仅是功能当中需要参与计算的数，则定义为形参变量。</p><p>    数学工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTool</span> </span>&#123;</span><br><span class="line"><span class="comment">//求两个数的和的二倍</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sum2times</span><span class="params">(<span class="keyword">int</span> number,<span class="keyword">int</span> number2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (number+number2)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求两个数的积</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> number,<span class="keyword">int</span> number2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> number*number2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    长方形类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CFX</span> </span>&#123;</span><br><span class="line"><span class="comment">//因为长与宽，在现实事物中属于事物的一部分，所以定义成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> chang;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> kuan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CFX</span><span class="params">(<span class="keyword">int</span> chang, <span class="keyword">int</span> kuan)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.chang = chang;</span><br><span class="line"><span class="keyword">this</span>.kuan = kuan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求长与宽的周长</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">zhouChang</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (chang+kuan)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求长与宽的面积</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mianJi</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> chang*kuan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getChang</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> chang;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChang</span><span class="params">(<span class="keyword">int</span> chang)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.chang = chang;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKuan</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> kuan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKuan</span><span class="params">(<span class="keyword">int</span> kuan)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.kuan = kuan;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.2    类作为方法参数与返回值</strong><br>Person类当做方法的参数<br>Person类型写在方法的参数列表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.classes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(name+ <span class="string">&quot;  在吃饭&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot; 在跑步&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.itcast.classes;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Person类,当作方法的参数</span></span><br><span class="line"><span class="comment"> *  Person类型写在方法的参数列表中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArguments</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用方法operatorPerson,传递Person类型对象</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">operatorPerson(p);</span><br><span class="line"><span class="comment">//传递有名对象p</span></span><br><span class="line">operatorPerson(<span class="keyword">new</span> Person());</span><br><span class="line"><span class="comment">//传递匿名对象，只能用一次,个人感觉，匿名对象可以理解为：定义了一个你不知道名字的类x，x用完就释放了</span></span><br><span class="line"><span class="comment">//但是在operatorPerson内存调用过这个名字x，x.eat() x.run()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  方法operatorPerson,参数类型是Person类型</span></span><br><span class="line"><span class="comment"> *  调用方法operatorPerson,必须传递Person类型的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operatorPerson</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line"><span class="comment">//可以使用引用类型p调用Person类的功能</span></span><br><span class="line">p.eat();</span><br><span class="line">p.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">张三  在吃饭</span><br><span class="line">张三 在跑步</span><br><span class="line">张三  在吃饭</span><br><span class="line">张三 在跑步</span><br></pre></td></tr></table></figure><p><strong>3.3    抽象类作为方法参数与返回值</strong><br>    抽象类作为方法参数<br>a是抽象类Animal cat是抽象类的子类<br>传参过程  方法：operatorAnimal(Animal a)，用到的是父类抽象类，传递进来的是子类cat c（只有传cat才能有编译，因为Animal抽象没有主体）<br>其实就是多态：Animal a = new cat:<br><strong>这种方法的优点：扩展性，既可以传cat又可以传dog</strong>条件：这两个都是Animal的子类，具有共同抽象方法eat<br>operatorAnimal(c);<br>也可以；operatorAnimal( new Dog()); 也可以调用Dog的eat方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.abstractclass;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  将抽象类类型,作为方法的参数进行传递</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArguments</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用operatorAnimal,传递子类对象</span></span><br><span class="line">Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">operatorAnimal(c);</span><br><span class="line"></span><br><span class="line">operatorAnimal( <span class="keyword">new</span> Dog());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  方法operatorAnimal,参数是一个抽象类</span></span><br><span class="line"><span class="comment"> *  调用方法,传递Animal类型对象,Animal抽象类没有对象</span></span><br><span class="line"><span class="comment"> *  只能传递Animal的子类的对象 (多态)</span></span><br><span class="line"><span class="comment"> *  可以传递Animal的任意的子类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operatorAnimal</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line"><span class="comment">//引用变量a,调用方法eat</span></span><br><span class="line">a.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**    抽象类作为方法返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetAnimal</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法,方法的返回值是Animal类型</span></span><br><span class="line"><span class="comment"> * 抽象类,抽象类没有对象的,因此在方法的return后,返回Animal 的子类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Animal <span class="title">getAnimal</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//要分清类的定义和方法的定义，方法的定义必须有返回值</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReturn</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用GetAnimal类的方法,getAnimal,返回值是Animal</span></span><br><span class="line">GetAnimal g = <span class="keyword">new</span> GetAnimal();</span><br><span class="line"></span><br><span class="line">Animal a= g.getAnimal(<span class="number">9</span>);<span class="comment">//方法的返回了Animal类型,return new Cat() </span></span><br><span class="line"><span class="comment">//getAnimal 返回的是Animal类，因此不能用cat类作为接收</span></span><br><span class="line"><span class="comment">//Cat a = g.getAnimal(9);  这是错误的</span></span><br><span class="line"><span class="comment">//问题：Animal不是抽象类吗，它还能eat？</span></span><br><span class="line"><span class="comment">//答案是肯定的，因为返回的类型虽然是Animal，但是return的是他的子类Dog或者Cat</span></span><br><span class="line"><span class="comment">//因此：这种方法可以理解为：Animal a= g.getAnimal(9);  等价于   Animal a = new（Cat）/new（Dog）</span></span><br><span class="line"><span class="comment">//好处在于：可以通过给getAnimal设定参数，选择返回的类型是Cat或者Dog，比之前死的返回这一种要好用</span></span><br><span class="line">a.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Python抽象类和抽象方法的定义"><a href="#Python抽象类和抽象方法的定义" class="headerlink" title="Python抽象类和抽象方法的定义"></a>Python抽象类和抽象方法的定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span>   ABCmeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>(<span class="params">metaclass=ABCmeta</span>):</span> <span class="comment">#创建抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod   </span><span class="comment">#定义抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_yourself</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m like you！！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">People</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_yourself</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Name is &#123;&#125;, age is &#123;&#125;, sex is &#123;&#125; &quot;</span>.<span class="built_in">format</span>(self.name, self.age, self.sex))</span><br><span class="line">        </span><br><span class="line">stu = Student(<span class="string">&quot;nlj&quot;</span>, <span class="number">30</span>, <span class="string">&quot;female&quot;</span>)</span><br><span class="line">stu.say()       </span><br></pre></td></tr></table></figure><p><strong>3.4    接口作为方法参数与返回值</strong><br>    接口作为方法参数<br>接口作为方法参数的情况是很常见的，经常会碰到。当遇到方法参数为接口类型时，那么该方法要传入一个接口实现类对象。如下代码演示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Smoke</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口定义抽象方法:    interface Smoke&#123;</span></span><br><span class="line"><span class="comment">//创建子类实现接口Smoke:    class Student implements Smoke&#123;</span></span><br><span class="line"><span class="comment">//创建测试类:public class Test &#123;</span></span><br><span class="line"><span class="comment">//在测试类中创建方法调用子类实现接口 public static void method(Smoke sm)&#123;//接口作为参数</span></span><br><span class="line"><span class="comment">//实际是通过sm变量调用smoking方法，这时实际调用的是Student对象中的smoking方法</span></span><br><span class="line"><span class="comment">//问题：如果有两个子类实现了Smoke接口的抽象方法，那么效果如何呢？</span></span><br><span class="line"><span class="comment">//答案：取决于你的Test中定义的子类属于哪一个实现类 STudent ？或者Student1</span></span><br><span class="line"><span class="comment">//Smoke s = new Student();//调用method方法，method(s);</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Smoke</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;别抽烟&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> <span class="keyword">implements</span> <span class="title">Smoke</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;老子就抽烟&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过多态的方式，创建一个Smoke类型的变量，而这个对象实际是Student</span></span><br><span class="line">Smoke s = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//调用method方法</span></span><br><span class="line">method(s); <span class="comment">//等价于 method(new Student())  利用匿名对象</span></span><br><span class="line">Smoke a = <span class="keyword">new</span> Student1(); </span><br><span class="line">method(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个方法method，用来接收一个Smoke类型对象，在方法中调用Smoke对象的show方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Smoke sm)</span></span>&#123;<span class="comment">//接口作为参数</span></span><br><span class="line"><span class="comment">//通过sm变量调用smoking方法，这时实际调用的是Student对象中的smoking方法</span></span><br><span class="line">sm.smoking();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">别抽烟</span><br><span class="line">老子就抽烟</span><br></pre></td></tr></table></figure><p><strong>3.4    接口作为方法参数与返回值</strong><br>    接口作为方法返回值<br>接口作为方法返回值的情况，在后面的学习中会碰到。当遇到方法返回值是接口类型时，那么该方法需要返回一个接口实现类对象。如下代码演示。<br>1、定义接口：interface Smoke｛<br>2、定义接口的实现类：class Student implements Smoke{<br>3、测试类中创建method方法  返回值类型是Smoke</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Smoke s = method();` </span><br></pre></td></tr></table></figure><pre><code>//调用method方法的返回值类型是Smoke，接收方式是左边的方法</code></pre><p>4、调用Smoke的方法s.smoking()<br>问题：怎么确定返回的Smoke接口中的重写方法对应的是Student?<br>答案：因为在Method中写出了调用的接口的实现类是Student，所以能够对应找到s.smoking()<br>如果你选择返回的是Student1的重写方法smoking，则需要修改method中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Smoke sm = <span class="keyword">new</span> Student();→Smoke sm = <span class="keyword">new</span> Student1();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Smoke</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Smoke</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;课下吸口烟，赛过活神仙&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> <span class="keyword">implements</span> <span class="title">Smoke</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;哈哈哈哈哈哈哈&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用method方法，获取返回的会吸烟的对象</span></span><br><span class="line">Smoke s = method();</span><br><span class="line"><span class="comment">//通过s变量调用smoking方法,这时实际调用的是Student对象中的smoking方法</span></span><br><span class="line">s.smoking();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个方法method，用来获取一个具备吸烟功能的对象，并在方法中完成吸烟者的创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Smoke <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">Smoke sm = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">return</span> sm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码解析：<br>1、定义一个抽象类Animal，抽象类的抽象方法是eat() 一个返回值类型是Animal类静态方法getInstance()（实际上返回的是Cat子类，所以有eat的重写方法）<br>2、定义一个cat子类继承抽象类Animal<br>3、下面这个代码，表面上没有cat实际上实在执行cat类中的eat<br>4、import java.util.Calendar;导入日历类，这个类实际上是一个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a = Animal.getInstance();</span><br><span class="line">a.eat();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 抽象类Animal,定义方法,返回值是Animal类型</span></span><br><span class="line"><span class="comment"> * 抽象类没有对象,此方法方便调用,写为静态修饰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span>  <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//直接调用抽象类的静态方法getInstance获取抽象类的子类的对象</span></span><br><span class="line"><span class="comment">//抽象类的静态方法,返回了自己的子类对象</span></span><br><span class="line"><span class="comment">//对于调用者来讲: 不需要关注子类是谁</span></span><br><span class="line">Animal a = Animal.getInstance();</span><br><span class="line">a.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//日历类</span></span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201201215827600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="星级酒店案例"><br>代码：day14 cn.itcast.hotel</p><p>接口是用来定义特殊特征（方法）的<br>继承抽象类 是用来重写共有特征（方法）的<br>厨师、服务员、经理的共有的 定义在abstract中<br>经理有一个private double money; 其他的都是public</p><h2 id="第1章-Java的API及Object类"><a href="#第1章-Java的API及Object类" class="headerlink" title="第1章 Java的API及Object类"></a>第1章 Java的API及Object类</h2><pre><code>    在以前的学习过程中，我们都在学习对象基本特征、对象的使用以及对象的关系。接下来我们开始使用对象做事情，那么在使用对象做事情之前，我们要学习一些API中提供的常用对象。首先在学习API中的Object类之前,先来学习如何使用API。</code></pre><p><strong>1.1    Java 的API</strong><br>Java 的API（API: Application(应用) Programming(程序) Interface(接口)）<br>Java API就是JDK中提供给我们使用的类，这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。<br>在JDK安装目录下有个src.zip文件，这个文件解压缩后里面的内容是所有Java类的源文件。可以在其中查看相对应的类的源码。<br>我们在每次查看类中的方法时，都打开源代码进行查看，这种方式过于麻烦。其实，我们可以通过查帮助文档的方式，来了解Java提供的API如何使用。如下图操作：查找Object类<br><strong>1.2    Object类概述</strong>：<br>Object类是Java语言中的<strong>根类</strong>，即<strong>所有类的父类</strong>。<br>它中描述的所有方法子类都可以使用。所有类在创建对象的时候，最终找的父类就是Object。<br>在Object类众多方法中，我们先学习equals方法与toString方法，其他方法后面课程中会陆续学到。</p><p><strong>1.3    equals方法</strong> ：作比较<br>equals方法，用于比较两个对象是否相同，它其实就是使用两个对象的内存地址在比较。Object类中的equals方法内部使用的就是==比较运算符。<br>在开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较，也就是在开发经常需要子类重写equals方法根据对象的属性值进行比较。如下代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 重写父类的方法toString()</span></span><br><span class="line"><span class="comment"> * 没有必要让调用者看到内存地址</span></span><br><span class="line"><span class="comment"> * 要求: 方法中,返回类中所有成员变量的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> name + age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将父类的equals方法写过来,重写父类的方法</span></span><br><span class="line"><span class="comment"> * 但是,不改变父类方法的源代码, 方法equals 比较两个对象的内存地址</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 两个对象,比较地址,没有意义</span></span><br><span class="line"><span class="comment"> * 比较两个对象的成员变量,age</span></span><br><span class="line"><span class="comment"> * 两个对象变量age相同,返回true,不同返回false</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 重写父类的equals,自己定义自己对象的比较方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">this</span> == obj)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对参数obj,非null判断</span></span><br><span class="line"><span class="keyword">if</span>( obj == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line"><span class="comment">// 参数obj接受到是Person对象,才能转型</span></span><br><span class="line"><span class="comment">// 对obj参数进行类型的向下转型,obj转成Person类型</span></span><br><span class="line">Person p = (Person)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age ==  p.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEquals</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Person类继承Object类,继承下来了父类的方法equals</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment">//Person对象p1,调用父类的方法equals,进行对象的比较</span></span><br><span class="line"><span class="keyword">boolean</span> b = p1.equals(p1);</span><br><span class="line">System.out.println(b);</span><br><span class="line"><span class="keyword">boolean</span> bo  = p1.equals(p2);</span><br><span class="line">System.out.println(bo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">this</span> == obj)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//这个equals中this = obj比较的是地址，因为只要new一次输出的地址都不同，所以没什么意义，</span></span><br><span class="line"><span class="comment">//因此，作者重写了equals，比较年龄，名称不比较。代码如上所示</span></span><br><span class="line">equals Peson类继承，重写了equals,源代码和父类的源代码是一样的</span><br><span class="line">equals中的<span class="keyword">this</span>指向的是调用者 p1  p1.equals(obj)  <span class="keyword">this</span> == obj:比较的是内存地址，内存地址不同所以返回<span class="keyword">false</span></span><br><span class="line">注意：因为equals的输入参数是object类的对象，所以需要进行一个向下转型，即，强转为Person类，这样才能进行age的比较</span><br><span class="line"><span class="keyword">if</span>( obj <span class="keyword">instanceof</span> Person)&#123;这句话的意思是，首先obj是Person类，才能进行强转换</span><br><span class="line">这句话是判断这个对象是不是Person类</span><br></pre></td></tr></table></figure><p><strong>1.4    toString方法</strong></p><p>toString方法返回该对象的字符串表示，其实该字符串内容就是<strong>对象的类型+@+内存地址值。</strong><br>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。<br>需要重写，不重写</p><blockquote><p>这里是引用</p></blockquote><p>返回的是内存地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age ;</span><br><span class="line"><span class="comment">//根据Person类的属性重写toString方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person [age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 第2章 String类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## String方法调用集锦重要，看懂以下代码就可以</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line"><span class="keyword">package</span> cn.itcast.demo02;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  String类的查找功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo4</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_9();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  boolean equals(Object obj)</span></span><br><span class="line"><span class="comment"> *  方法传递字符串,判断字符串中的字符是否完全相同,如果完全相同返回true</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  boolean equalsIgnoreCase(String s)</span></span><br><span class="line"><span class="comment"> *  传递字符串,判断字符串中的字符是否相同,忽略大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_9</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str1 = <span class="string">&quot;Abc&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//分别调用equals和equalsIgnoreCase</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = str1.equals(str2);</span><br><span class="line"><span class="keyword">boolean</span> b2 = str1.equalsIgnoreCase(str2);</span><br><span class="line">System.out.println(b1);</span><br><span class="line">System.out.println(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * char[] toCharArray() 将字符串转成字符数组</span></span><br><span class="line"><span class="comment"> * 功能和构造方法相反</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_8</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line"><span class="comment">//调用String类的方法toCharArray()</span></span><br><span class="line"><span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ch.length ; i++)&#123;</span><br><span class="line">System.out.println(ch[i]);</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">i</span><br><span class="line">t</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">s</span><br><span class="line">t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  byte[] getBytes() 将字符串转成字节数组</span></span><br><span class="line"><span class="comment"> *  此功能和String构造方法相反</span></span><br><span class="line"><span class="comment"> *  byte数组相关的功能,查询编码表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_7</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//调用String类方法getBytes字符串转成字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bytes.length ; i++)&#123;</span><br><span class="line">System.out.println(bytes[i]);<span class="comment">//输出：97 98 99</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  int indexOf(char ch)</span></span><br><span class="line"><span class="comment"> *  查找一个字符,在字符串中第一次出现的索引</span></span><br><span class="line"><span class="comment"> *  被查找的字符不存在,返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_6</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;itcast.cn&quot;</span>;</span><br><span class="line"><span class="comment">//调用String类的方法indexOf</span></span><br><span class="line"><span class="keyword">int</span> index = str.indexOf(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">System.out.println(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  boolean contains (String s)</span></span><br><span class="line"><span class="comment"> *  判断一个字符串中,是否包含另一个字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_5</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;itcast.cn&quot;</span>;</span><br><span class="line"><span class="comment">//调用String类的方法contains</span></span><br><span class="line"><span class="keyword">boolean</span> b =str.contains(<span class="string">&quot;ac&quot;</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * boolean endsWith(String prefix)</span></span><br><span class="line"><span class="comment"> * 判断一个字符串是不是另一个字符串的后缀,结尾</span></span><br><span class="line"><span class="comment"> * Demo.java</span></span><br><span class="line"><span class="comment"> *     .java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_4</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;Demo.java&quot;</span>;</span><br><span class="line"><span class="comment">//调用String类方法endsWith</span></span><br><span class="line"><span class="keyword">boolean</span> b = str.endsWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">System.out.println(b);<span class="comment">//输出：true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * boolean startsWith(String prefix)  </span></span><br><span class="line"><span class="comment"> * 判断一个字符串是不是另一个字符串的前缀,开头</span></span><br><span class="line"><span class="comment"> * howareyou</span></span><br><span class="line"><span class="comment"> * hOw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String str = <span class="string">&quot;howareyou&quot;</span>;</span><br><span class="line">  <span class="comment">//调用String类的方法startsWith</span></span><br><span class="line">  <span class="keyword">boolean</span> b = str.startsWith(<span class="string">&quot;hOw&quot;</span>);</span><br><span class="line">  System.out.println(b);<span class="comment">//测试是否以hOw开始，输出false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  String substring(int beginIndex,int endIndex) 获取字符串的一部分</span></span><br><span class="line"><span class="comment"> *  返回新的字符串</span></span><br><span class="line"><span class="comment"> *  包含头,不包含尾巴</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  String substring(int beginIndex)获取字符串的一部分</span></span><br><span class="line"><span class="comment"> *  包含头,后面的字符全要</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;howareyou&quot;</span>;</span><br><span class="line"><span class="comment">//调用String类方法substring获取字符串一部分</span></span><br><span class="line">str= str.substring(<span class="number">1</span>, <span class="number">5</span>);<span class="comment">//字符串定义之后不能修改，所以打印结果还是str</span></span><br><span class="line">System.out.println(str);<span class="comment">//输出：owar</span></span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">str2 = str2.substring(<span class="number">1</span>);<span class="comment">//截取操作需要另一个字符串去接收，只有一个int输入：包含头，后面的字符全都要</span></span><br><span class="line">System.out.println(str2);<span class="comment">//输出；elloWorld</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  int length() 返回字符串的长度</span></span><br><span class="line"><span class="comment"> *  包含多少个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;cfxdf#$REFewfrt54GT&quot;</span>;</span><br><span class="line"><span class="comment">//调用String类方法length,获取字符串长度</span></span><br><span class="line"><span class="keyword">int</span> length = str.length();</span><br><span class="line">System.out.println(length);<span class="comment">//输出19</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.1    String类的概述</strong><br>查阅API中的String类的描述，发现String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> *   String类特点:</span><br><span class="line"> *     一切都是对象,字符串事物 <span class="string">&quot;&quot;</span> 也是对象</span><br><span class="line"> *     类是描述事物,String类,描述字符串对象的类</span><br><span class="line"> *     所有的 <span class="string">&quot;&quot;</span> 都是String类的对象</span><br><span class="line"> *     </span><br><span class="line"> *     字符串是一个常量,一旦创建,不能改变</span><br><span class="line"><span class="comment">//演示字符串</span></span><br><span class="line">String str  = <span class="string">&quot;itcast&quot;</span>;  <span class="comment">//&quot;itcast&quot;是对象  str是引用类型的变量  不需要写new</span></span><br><span class="line"><span class="comment">//String也是object子类</span></span><br><span class="line">str = <span class="string">&quot;传智播客&quot;</span>;</span><br></pre></td></tr></table></figure><p>继续查API发现，字符串有大量的重载的构造方法。通过String类的构造方法可以完成字符串对象的创建，那么，通过使用双引号的方式创建对象与new的方式创建对象，有什么不同呢？看如下程序与图解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s3==s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3.equals(s4));<span class="comment">//true,</span></span><br><span class="line"><span class="comment">//因为String重写了equals方法，建立了字符串自己的判断相同的依据（通过字符串对象中的字符来判断）</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//字符串定义方式2个, 直接=  使用String类的构造方法</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//引用数据类型,比较对象的地址 false</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：  字符串.equals比较的是对象每隔字符是否相同（String是Object的子类，因此String重写了equals）</span></span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">s3和s4的创建方式有什么不同呢？</span></span><br><span class="line"><span class="string">s3创建，在内存中只有一个对象。这个对象在字符串常量池中</span></span><br><span class="line"><span class="string">s4创建，在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象，在字符串常量池中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">​```java</span></span><br><span class="line"><span class="string">package cn.itcast.demo02;</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> *   String类特点:</span></span><br><span class="line"><span class="string"> *     一切都是对象,字符串事物 &quot;&quot; 也是对象</span></span><br><span class="line"><span class="string"> *     类是描述事物,String类,描述字符串对象的类</span></span><br><span class="line"><span class="string"> *     所有的 &quot;&quot; 都是String类的对象</span></span><br><span class="line"><span class="string"> *     </span></span><br><span class="line"><span class="string"> *     字符串是一个常量,一旦创建,不能改变</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">public class StringDemo &#123;</span></span><br><span class="line"><span class="string">public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">//引用变量str执行内存变化</span></span><br><span class="line"><span class="string">//定义好的字符串对象,不变</span></span><br><span class="line"><span class="string">String str = &quot;itcast&quot;;</span></span><br><span class="line"><span class="string">System.out.println(str);</span></span><br><span class="line"><span class="string">str = &quot;itheima&quot;;</span></span><br><span class="line"><span class="string">System.out.println(str);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>2.2    String类构造方法</strong>   有很多构造方法<br>构造方法是用来完成String对象的创建，下图中给出了一部分构造方法需要在API中找到，并能够使用下列构造方法创建对象。<br>day15 StringDemo3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo02;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  String类构造方法</span></span><br><span class="line"><span class="comment">  *  String类的构造方法,重载形式</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * String(char[] value) 传递字符数组</span></span><br><span class="line"><span class="comment"> * 将字符数组,转成字符串, 字符数组的参数,不查询编码表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * String(char[] value, int offset, int count) 传递字符数组</span></span><br><span class="line"><span class="comment"> * 将字符数组的一部分转成字符串</span></span><br><span class="line"><span class="comment"> * offset  数组开始索引</span></span><br><span class="line"><span class="comment"> * count   个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//调用String构造方法,传递字符数组</span></span><br><span class="line">String s = <span class="keyword">new</span> String(ch);</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">String s1 = <span class="keyword">new</span> String(ch,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义方法,String类的构造方法</span></span><br><span class="line"><span class="comment"> *  String(byte[] bytes)  传递字节数组</span></span><br><span class="line"><span class="comment"> *  字节数组转成字符串</span></span><br><span class="line"><span class="comment"> *  通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</span></span><br><span class="line"><span class="comment"> *  平台 : 机器操作系统</span></span><br><span class="line"><span class="comment"> *  默认字符集: 操作系统中的默认编码表, 默认编码表GBK</span></span><br><span class="line"><span class="comment"> *  将字节数组中的每个字节,查询了编码表,得到的结果</span></span><br><span class="line"><span class="comment"> *  字节是负数,汉字的字节编码就是负数, 默认编码表 ,一个汉字采用2个字节表示</span></span><br><span class="line"><span class="comment"> * 即：｛-97，-98｝这表示一个汉字</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  String(byte[] bytes, int offset, int length) 传递字节数组</span></span><br><span class="line"><span class="comment"> *  字节数组的一部分转成字符串</span></span><br><span class="line"><span class="comment"> *  offset 数组的起始的索引</span></span><br><span class="line"><span class="comment"> *  length 个数,转几个   , 不是结束的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">//调用String类的构造方法,传递字节数组</span></span><br><span class="line">String s = <span class="keyword">new</span> String(bytes);</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes1 =&#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>,<span class="number">69</span>&#125;;<span class="comment">//对应ABCDE</span></span><br><span class="line"><span class="comment">//调用String构造方法,传递数组,传递2个int值</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(bytes1,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//0是起始位置，2是几个</span></span><br><span class="line">System.out.println(s1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(); <span class="comment">//创建String对象，字符串中没有内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(bys); <span class="comment">// 创建String对象，把数组元素作为字符串的内容</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(bys, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">//创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数length为要几个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;’a’,’b’,’c’,’d’,’e’&#125;;</span><br><span class="line">String s4 = <span class="keyword">new</span> String(chs); <span class="comment">//创建String对象，把数组元素作为字符串的内容</span></span><br><span class="line">String s5 = <span class="keyword">new</span> String(chs, <span class="number">0</span>, <span class="number">3</span>);<span class="comment">//创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数count为要几个元素</span></span><br><span class="line">String s6 = <span class="keyword">new</span> String(“abc”); <span class="comment">//创建String对象，字符串内容为abc</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**2.3String类的方法查找**</span><br><span class="line">String类中有很多的常用的方法，我们在学习一个类的时候，不要盲目的把所有的方法尝试去使用一遍，这时我们应该根据这个对象的特点分析这个对象应该具备那些功能，这样大家应用起来更方便。</span><br><span class="line">字符串是一个对象，那么它的方法必然是围绕操作这个对象的数据而定义的。我们想想字符串中有哪些功能呢？</span><br><span class="line">字符串中有多少个字符?</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;java</span><br><span class="line">String str &#x3D; &quot;abcde&quot;;</span><br><span class="line">int len &#x3D; str.length();</span><br><span class="line">System.out.println(&quot;len&#x3D;&quot;+len);</span><br></pre></td></tr></table></figure><p>    获取部分字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String s1 = str.substring(<span class="number">1</span>); <span class="comment">//返回一个新字符串，内容为指定位置开始到字符串末尾的所有字符</span></span><br><span class="line">String s2 = str.substring(<span class="number">2</span>, <span class="number">4</span>);<span class="comment">//返回一个新字符串，内容为指定位置开始到指定位置结束所有字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;str=&quot;</span>+str);</span><br><span class="line">System.out.println(<span class="string">&quot;s1=&quot;</span>+s1);</span><br><span class="line">System.out.println(<span class="string">&quot;s2=&quot;</span>+s2);</span><br></pre></td></tr></table></figure><h2 id="3-1-StringBuffer类"><a href="#3-1-StringBuffer类" class="headerlink" title="3.1 StringBuffer类"></a>3.1 StringBuffer类</h2><p>在学习String类时，API中说字符串缓冲区支持可变的字符串，什么是字符串缓冲区呢？接下来我们来研究下字符串缓冲区。<br>查阅StringBuffer的API，<strong>StringBuffer又称为可变字符序列</strong>，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以<strong>改变该序列的长度和内容</strong>。<br>原来<strong>StringBuffer是个字符串的缓冲区</strong>，即就是它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>StringBuffer一系列基本操作：<br>看懂基础代码及调用格式即可</p><p>.append：将指定的字符串追加到此字符序列<br>.delete：移除次序列的子字符串的字符<br>.insert：将字符串插入此字符序列<br>.replace：使用给定String中的字符替换此序列的子字符串中的字符<br>.reverse：将此字符串序列用其反转形式取代<br>.toString：返回此序列中数据的字符串表示形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_5();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类的方法</span></span><br><span class="line"><span class="comment"> *   String toString() 继承Object,重写toString()</span></span><br><span class="line"><span class="comment"> *   将缓冲区中的所有字符,变成字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_5</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">buffer.append(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将可变的字符串缓冲区对象,变成了不可变String对象</span></span><br><span class="line">String s = buffer.toString();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：abcdef12345</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类的方法</span></span><br><span class="line"><span class="comment"> *    reverse() 将缓冲区中的字符反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_4</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">buffer.reverse();</span><br><span class="line"></span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：fedcba</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类方法</span></span><br><span class="line"><span class="comment"> *    replace(int start,int end, String str)</span></span><br><span class="line"><span class="comment"> *    将指定的索引范围内的所有字符,替换成新的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">buffer.replace(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">// 将1到4索引（四个字符）替换成一个Q</span></span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：aQef</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类方法 insert</span></span><br><span class="line"><span class="comment"> *    insert(int index, 任意类型)</span></span><br><span class="line"><span class="comment"> *  将任意类型数据,插入到缓冲区的指定索引上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line"> StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"> buffer.append(<span class="string">&quot;abcdef&quot;</span>); </span><br><span class="line"> </span><br><span class="line"> buffer.insert(<span class="number">3</span>, <span class="number">9.5</span>);<span class="comment">//在3索引处增加一个9.5</span></span><br><span class="line"> System.out.println(buffer);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//abc9.5def</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * StringBuffer类方法</span></span><br><span class="line"><span class="comment"> *   delete(int start,int end) 删除缓冲区中字符</span></span><br><span class="line"><span class="comment"> *   开始索引包含,结尾索引不包含</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">buffer.delete(<span class="number">1</span>,<span class="number">5</span>);<span class="comment">//从1索引开始删除5个</span></span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：af</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类方法</span></span><br><span class="line"><span class="comment"> *   StringBuffer append, 将任意类型的数据,添加缓冲区</span></span><br><span class="line"><span class="comment"> *   append 返回值,写return this</span></span><br><span class="line"><span class="comment"> *   调用者是谁,返回值就是谁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//调用StringBuffer方法append向缓冲区追加内容</span></span><br><span class="line">buffer.append(<span class="number">6</span>).append(<span class="keyword">false</span>).append(<span class="string">&#x27;a&#x27;</span>).append(<span class="number">1.5</span>);</span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出；6falsea1.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码任务描述：</strong><br>任务：将一个int[]中元素转成字符串<br>输入：int[] arr = {34,12,89,68};<br>输出：格式 [34,12,89,68]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">76</span>&#125;;</span><br><span class="line">System.out.println(arr);</span><br><span class="line"><span class="comment">//为什么这样打印的是：[I@1d1e730</span></span><br><span class="line">System.out.println(toString(arr));</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 任务：将一个int[]中元素转成字符串 </span></span><br><span class="line"><span class="comment">    * 输入：int[] arr = &#123;34,12,89,68&#125;;</span></span><br><span class="line"><span class="comment">    * 输出：格式 [34,12,89,68]</span></span><br><span class="line"><span class="comment">    * String s = &quot;[&quot;</span></span><br><span class="line"><span class="comment">    * 数组遍历</span></span><br><span class="line"><span class="comment">    *   s+= arr[i];</span></span><br><span class="line"><span class="comment">    *  s+&quot;]&quot;</span></span><br><span class="line"><span class="comment">    *  StringBuffer实现,节约内存空间, String + 在缓冲区中,append方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建字符串缓冲区</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"><span class="comment">//数组遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++)&#123;</span><br><span class="line"><span class="comment">//判断是不是数组的最后一个元素</span></span><br><span class="line"><span class="keyword">if</span>(i == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">buffer.append(arr[i]).append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">buffer.append(arr[i]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buffer.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3-正则表达式规则匹配练习"><a href="#1-3-正则表达式规则匹配练习" class="headerlink" title="1.3 正则表达式规则匹配练习"></a>1.3 正则表达式规则匹配练习</h2><p>syso   alt+/<br><strong>1.1    正则表达式的概念</strong><br>    正则表达式（英语：Regular Expression，在代码中常简写为regex）。<br>    正则表达式是一个字符串，使用单个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。</p><p><strong>1.2    正则表达式的匹配规则</strong><br>    参照帮助文档，在Pattern类中有正则表达式的的规则定义，正则表达式中明确区分大小写字母。我们来学习语法规则。<br>    正则表达式的语法规则：<br>    字符：x<br>    含义：代表的是字符x<br>    例如：匹配规则为 “a”，那么需要匹配的字符串内容就是 ”a”</p><pre><code>字符：\\    翻译：将转义字符转义为普通斜线，失去了转义字符的意思含义：代表的是反斜线字符&#39;\&#39;例如：匹配规则为&quot;\\&quot; ，那么需要匹配的字符串内容就是 ”\”字符：\t含义：制表符例如：匹配规则为&quot;\t&quot; ，那么对应的效果就是产生一个制表符的空间字符：\n含义：换行符例如：匹配规则为&quot;\n&quot;，那么对应的效果就是换行,光标在原有位置的下一行字符：\r含义：回车符例如：匹配规则为&quot;\r&quot; ，那么对应的效果就是回车后的效果,光标来到下一行行首字符类：[abc]含义：代表的是字符a、b 或 c例如：匹配规则为&quot;[abc]&quot; ，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个字符类：[^abc]含义：代表的是除了 a、b 或 c以外的任何字符例如：匹配规则为&quot;[^abc]&quot;，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符字符类：[a-zA-Z]含义：代表的是a 到 z 或 A 到 Z，两头的字母包括在内例如：匹配规则为&quot;[a-zA-Z]&quot;，那么需要匹配的是一个大写或者小写字母字符类：[0-9]含义：代表的是 0到9数字，两头的数字包括在内例如：匹配规则为&quot;[0-9]&quot;，那么需要匹配的是一个数字字符类：[a-zA-Z_0-9]含义：代表的字母或者数字或者下划线(即单词字符)例如：匹配规则为&quot; [a-zA-Z_0-9] &quot;，那么需要匹配的是一个字母或者是一个数字或一个下滑线预定义字符类：.含义：代表的是任何字符例如：匹配规则为&quot; . &quot;，那么需要匹配的是一个任意字符。如果，就想使用 . 的话，使用匹配规则&quot;\\.&quot;来实现预定义字符类：\d含义：代表的是 0到9数字，两头的数字包括在内，相当于[0-9]例如：匹配规则为&quot;\d &quot;，那么需要匹配的是一个数字预定义字符类：\w含义：代表的字母或者数字或者下划线(即单词字符)，相当于[a-zA-Z_0-9]例如：匹配规则为&quot;\w &quot;，，那么需要匹配的是一个字母或者是一个数字或一个下滑线边界匹配器：^含义：代表的是行的开头例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容从[abc]这个位置开始, 相当于左双引号边界匹配器：$含义：代表的是行的结尾例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容以[0-9]这个结束, 相当于右双引号边界匹配器：\b含义：代表的是单词边界例如：匹配规则为&quot;\b[abc]\b&quot; ，那么代表的是字母a或b或c的左右两边需要的是非单词字符([a-zA-Z_0-9])数量词：X?含义：代表的是X出现一次或一次也没有例如：匹配规则为&quot;a?&quot;，那么需要匹配的内容是一个字符a，或者一个a都没有数量词：X*含义：代表的是X出现零次或多次例如：匹配规则为&quot;a*&quot; ，那么需要匹配的内容是多个字符a，或者一个a都没有数量词：X+含义：代表的是X出现一次或多次例如：匹配规则为&quot;a+&quot;，那么需要匹配的内容是多个字符a，或者一个a数量词：X&#123;n&#125;含义：代表的是X出现恰好 n 次例如：匹配规则为&quot;a&#123;5&#125;&quot;，那么需要匹配的内容是5个字符a数量词：X&#123;n,&#125;含义：代表的是X出现至少 n 次例如：匹配规则为&quot;a&#123;5, &#125;&quot;，那么需要匹配的内容是最少有5个字符a数量词：X&#123;n,m&#125;含义：代表的是X出现至少 n 次，但是不超过 m 次例如：匹配规则为&quot;a&#123;5,8&#125;&quot;，那么需要匹配的内容是有5个字符a 到 8个字符a之间</code></pre><p><strong>1.3    正则表达式规则匹配练习</strong><br>请写出满足如下匹配规则的字符串:<br><strong>规则：”[0-9]{6,12}”<br>该规则需要匹配的内容是：长度为6位到12位的数字。</strong><br>如：使用数据”123456789”进行匹配结果为true；<br>使用数据”12345”进行匹配结果为false。</p><p><strong>规则：”1[34578][0-9]{9}”<br>该规则需要匹配的内容是：11位的手机号码，第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数</strong>字。<br>如：使用数据”12345678901”进行匹配结果为false；<br>使用数据”13312345678”进行匹配结果为true。</p><p>规则：”a*b”<br>该规则需要匹配的内容是：在多个a或零个a后面有个b；b必须为最后一个字符。<br>如：使用数据”aaaaab”进行匹配结果为true；<br>使用数据”abc”进行匹配结果为false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  实现正则规则和字符串进行匹配,使用到字符串类的方法</span></span><br><span class="line"><span class="comment"> *  String类三个和正则表达式相关的方法</span></span><br><span class="line"><span class="comment"> *    boolean matches(String 正则的规则)</span></span><br><span class="line"><span class="comment"> *    &quot;abc&quot;.matches(&quot;[a]&quot;)  匹配成功返回true</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *    String[] split(String 正则的规则)</span></span><br><span class="line"><span class="comment"> *    &quot;abc&quot;.split(&quot;a&quot;) 使用规则将字符串进行切割</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *    String replaceAll( String 正则规则,String 字符串)</span></span><br><span class="line"><span class="comment"> *    &quot;abc0123&quot;.repalceAll(&quot;[\\d]&quot;,&quot;#&quot;)</span></span><br><span class="line"><span class="comment"> *    按照正则的规则,替换字符串</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">checkTel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查手机号码是否合法</span></span><br><span class="line"><span class="comment"> *  1开头 可以是34578  0-9 位数固定11位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkTel</span><span class="params">()</span></span>&#123;</span><br><span class="line">String telNumber = <span class="string">&quot;1335128005&quot;</span>;</span><br><span class="line"><span class="comment">//String类的方法matches</span></span><br><span class="line"><span class="keyword">boolean</span> b = telNumber.matches(<span class="string">&quot;1[34857][\\d]&#123;9&#125;&quot;</span>);</span><br><span class="line"><span class="comment">//为什么第二位不需要空格或者逗号呢，记住吧</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查QQ号码是否合法</span></span><br><span class="line"><span class="comment"> *  0不能开头,全数字, 位数5,10位</span></span><br><span class="line"><span class="comment"> *  123456 </span></span><br><span class="line"><span class="comment"> *  \\d  \\D匹配不是数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">String QQ = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment">//检查QQ号码和规则是否匹配,String类的方法matches</span></span><br><span class="line"><span class="keyword">boolean</span> b = QQ.matches(<span class="string">&quot;[1-9][\\d]&#123;4,9&#125;&quot;</span>);   <span class="comment">// \d  表示0到9  那为什么这里用\\d呢</span></span><br><span class="line"><span class="comment">//原因：\\d，第一个\转义第二个\,这样才表示\d</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">replaceAll_1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &quot;Hello12345World6789012&quot;将所有数字替换掉</span></span><br><span class="line"><span class="comment"> * String类方法replaceAll(正则规则,替换后的新字符串)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replaceAll_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;Hello12345World6789012&quot;</span>;</span><br><span class="line">str = str.replaceAll(<span class="string">&quot;[\\d]+&quot;</span>, <span class="string">&quot;#&quot;</span>);<span class="comment">//将每个数字串改成#</span></span><br><span class="line"><span class="comment">//str = str.replaceAll(&quot;[\\d]&quot;, &quot;#&quot;);将每个数字改成#</span></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">输出：Hello#World#</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * String类方法split对字符串进行切割</span></span><br><span class="line"><span class="comment"> * 192.168.105.27 按照 点切割字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">String ip = <span class="string">&quot;192.168.105.27&quot;</span>;</span><br><span class="line">String[] strArr = ip.split(<span class="string">&quot;\\.&quot;</span>);<span class="comment">//转移成普通的.，否则输出的是空的数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;数组的长度&quot;</span>+strArr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strArr.length ; i++)&#123;</span><br><span class="line">System.out.println(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：数组的长度<span class="number">4</span></span><br><span class="line"><span class="number">192</span></span><br><span class="line"><span class="number">168</span></span><br><span class="line"><span class="number">105</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * String类方法split对字符串进行切割</span></span><br><span class="line"><span class="comment"> * 18 22 40 65 按照空格切割字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;18    22     40          65&quot;</span>;</span><br><span class="line">String[] strArr = str.split(<span class="string">&quot; +&quot;</span>);  <span class="comment">//+代表的是空格出现一次或多次</span></span><br><span class="line">System.out.println(<span class="string">&quot;数组的长度&quot;</span>+strArr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strArr.length ; i++)&#123;</span><br><span class="line">System.out.println(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：数组的长度<span class="number">4</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  String类方法split对字符串进行切割</span></span><br><span class="line"><span class="comment"> *  12-25-36-98  按照-对字符串进行切割</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;12-25-36-98&quot;</span>;</span><br><span class="line"><span class="comment">//按照-对字符串进行切割,String类方法split</span></span><br><span class="line">String[] strArr = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;数组的长度&quot;</span>+strArr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strArr.length ; i++)&#123;</span><br><span class="line">System.out.println(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">   输出：数组的长度<span class="number">4</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.5    正则表达式练习<br>    匹配正确的数字<br>匹配规则：<br>    匹配正整数：”\d+”<br>    匹配正小数：”\d+\.\d+”<br>    匹配负整数：”-\d+”<br>    匹配负小数：”-\d+\.\d+”<br>    匹配保留两位小数的正数：”\d+\.\d{2}”<br>    匹配保留1-3位小数的正数：”\d+\.\d{1,3}”</p><p>    匹配合法的邮箱<br>匹配规则：<br>    ”[a-zA-Z_0-9]+@[a-zA-Z_0-9]+(\.[a-zA-Z_0-9]+)+”<br>    ”\w+@\w+(\.\w+)+”</p><p>    获取IP地址(192.168.1.100)中的每段数字<br>匹配规则：<br>    ”\.”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">checkMail();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查邮件地址是否合法</span></span><br><span class="line"><span class="comment"> *  规则:</span></span><br><span class="line"><span class="comment"> *   1234567@qq.com</span></span><br><span class="line"><span class="comment"> *   mym_ail@sina.com</span></span><br><span class="line"><span class="comment"> *   nimail@163.com</span></span><br><span class="line"><span class="comment"> *   wodemail@yahoo.com.cn    </span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *   @: 前  数字字母_ 个数不能少于1个</span></span><br><span class="line"><span class="comment"> *   @: 后  数字字母     个数不能少于1个</span></span><br><span class="line"><span class="comment"> *   .: 后面 字母 </span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">String email =<span class="string">&quot;abc123@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = email.matches(<span class="string">&quot;[a-zA-Z0-9_]+@[0-9a-z]+(\\.[a-z]+)+&quot;</span>);</span><br><span class="line"> <span class="comment">//含义：代表的字母或者数字或者下划线(即单词字符)，看不懂就去上面查字符类</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第2章-Date"><a href="#第2章-Date" class="headerlink" title="第2章 Date"></a>第2章 Date</h2><p><strong>2.1    Date类概述</strong><br>类 Date 表示特定的瞬间，精确到毫秒。<br>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><p>//创建日期对象，把当前的毫秒值转成日期对象<br>Date date = new Date(1607616000000L);<br>System.out.println(date);<br>//打印结果：Fri Dec 11 00:00:00 CST 2020<br>可是将毫秒值转成日期后，输出的格式不利于我们阅读，继续查阅API，Date中有getYear、getMouth等方法，可以他们已经过时，继续往下查阅，看到了toString方法。</p><p>点开toString()方法查阅，原来上面打印的date对象就是默认调用了这个toString方法，并且在这个方法下面还有让我们参见toLocaleString方法，点进去，这个方法又过时了，从 JDK 1.1 开始，由 DateFormat.format(Date date) 取代。<br>既然这个方法被DateFormat.format(Date date) 取代，那么就要去查阅DateFormat类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  时间和日期类</span></span><br><span class="line"><span class="comment"> *    java.util.Date</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *  毫秒概念: 1000毫秒=1秒</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  毫秒的0点: </span></span><br><span class="line"><span class="comment"> *     System.currentTimeMillis() 返回值long类型参数</span></span><br><span class="line"><span class="comment"> *     获取当前日期的毫秒值   3742769374405</span></span><br><span class="line"><span class="comment"> *     时间原点; 公元1970年1月1日,午夜0:00:00 英国格林威治  毫秒值就是0</span></span><br><span class="line"><span class="comment"> *     时间2088年8月8日</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  重要: 时间和日期的计算,必须依赖毫秒值</span></span><br><span class="line"><span class="comment"> *    XXX-XXX-XX = 毫秒</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * long time = System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">System.out.println(time);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Date类方法 setTime(long )传递毫秒值</span></span><br><span class="line"><span class="comment"> * 将日期对象,设置到指定毫秒值上</span></span><br><span class="line"><span class="comment"> * 毫秒值转成日期对象</span></span><br><span class="line"><span class="comment"> * 输出：Sun Dec 06 22:51:28 CST 2020</span></span><br><span class="line"><span class="comment">   Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Date的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line">date.setTime(<span class="number">0</span>);</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   Date类方法 getTime() 返回值long</span></span><br><span class="line"><span class="comment"> *   返回的是毫秒值</span></span><br><span class="line"><span class="comment"> *   将Date表示的日期,转成毫秒值</span></span><br><span class="line"><span class="comment"> *   输出：1607266158056</span></span><br><span class="line"><span class="comment"> *   日期和毫秒值转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">long</span> time = date.getTime();<span class="comment">//将data表示的日期转换为毫秒值</span></span><br><span class="line">System.out.println(time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Date类的long参数的构造方法</span></span><br><span class="line"><span class="comment"> * Date(long ) 表示毫秒值</span></span><br><span class="line"><span class="comment"> * 传递毫秒值,将毫秒值转成对应的日期对象</span></span><br><span class="line"><span class="comment"> * 输出： Thu Jan 01 08:00:00 CST 1970   传递一个毫秒值，将毫秒值转换为对应的日期，Java从1970 00 00 00 开始（这个时区和格林威治时间有八个小时的时差）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">0</span>);</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Date类空参数构造方法</span></span><br><span class="line"><span class="comment"> * 获取到的是,当前操作系统中的时间和日期</span></span><br><span class="line"><span class="comment"> *输出： Sun Dec 06 22:47:39 CST 2020</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第3章-DateFormat"><a href="#第3章-DateFormat" class="headerlink" title="第3章 DateFormat"></a>第3章 DateFormat</h2><p><strong>3.1    DateFormat类概述</strong><br>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat类）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。<br>我们通过这个类可以帮我们完成日期和文本之间的转换。<br>继续阅读API，DateFormat 可帮助进行格式化并解析任何语言环境的日期。对于月、星期，甚至日历格式（阴历和阳历），<strong>其代码可完全与语言环境的约定无关。<br>3.2    日期格式</strong><br>要格式化一个当前语言环境下的日期也就是日期 -&gt; 文本），要通过下面的方法来完成。DateFormat是抽象类，我们需要使用其子类SimpleDateFormat来创建对象。<br>    构造方法</p><p>    DateFormat类方法</p><p>代码演示：<br>//创建日期格式化对象,在获取格式化对象时可以指定风格<br>DateFormat df= new SimpleDateFormat(“yyyy-MM-dd”);//对日期进行格式化<br>Date date = new Date(1607616000000L);<br>String str_time = df.format(date);<br>System.out.println(str_time);//2020年12月11日<br>    DateFormat类的作用：即可以将一个Date对象转换为一个符合指定格式的字符串，也可以将一个符合指定格式的字符串转为一个Date对象。<br>指定格式的具体规则我们可参照SimpleDateFormat类的说明，这里做简单介绍，规则是在一个字符串中，会将以下字母替换成对应时间组成部分，剩余内容原样输出：<br>    当出现y时，会将y替换成年<br>    当出现M时，会将M替换成月<br>    当出现d时，会将d替换成日<br>    当出现H时，会将H替换成时<br>    当出现m时，会将m替换成分<br>    当出现s时，会将s替换成秒<br><strong>3.3    DateFormat类常用方法</strong></p><p>    format方法，用来将Date对象转换成String<br>    parse方法，用来将String转换成Date（转换时，该String要符合指定格式，否则不能转换）。<br>代码演示：<br>练习一：把Date对象转换成String<br>     Date date = new Date(1607616000000L);//Fri Dec 11 00:00:00 CST 2020<br>    DateFormat df = new SimpleDateFormat(“yyyy年MM月dd日”);<br>    String str = df.format(date);<br>    //str中的内容为2020年12月11日</p><p>练习二：把String转换成Date对象<br>    String str = ”2020年12月11日”;<br>    DateFormat df = new SimpleDateFormat(“yyyy年MM月dd日”);<br>    Date date = df.parse( str );<br>    //Date对象中的内容为Fri Dec 11 00:00:00 CST 2020<br><strong>日期格式化</strong>format</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  对日期进行格式化 (自定义)</span></span><br><span class="line"><span class="comment"> *    对日期格式化的类 java.text.DateFormat 抽象类, 普通方法,也有抽象的方法</span></span><br><span class="line"><span class="comment"> *    实际使用是子类 java.text.SimpleDateFormat 可以使用父类普通方法,重写了抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何对日期格式化</span></span><br><span class="line"><span class="comment"> *  步骤:</span></span><br><span class="line"><span class="comment"> *    1. 创建SimpleDateFormat对象</span></span><br><span class="line"><span class="comment"> *       在类构造方法中,写入字符串的日期格式 (自己定义)</span></span><br><span class="line"><span class="comment"> *    2. SimpleDateFormat调用方法format对日期进行格式化</span></span><br><span class="line"><span class="comment"> *         String format(Date date) 传递日期对象,返回字符串</span></span><br><span class="line"><span class="comment"> *    日期模式:</span></span><br><span class="line"><span class="comment"> *       yyyy    年份</span></span><br><span class="line"><span class="comment"> *       MM      月份</span></span><br><span class="line"><span class="comment"> *       dd      月中的天数</span></span><br><span class="line"><span class="comment"> *       HH       0-23小时</span></span><br><span class="line"><span class="comment"> *       mm      小时中的分钟</span></span><br><span class="line"><span class="comment"> *       ss      秒</span></span><br><span class="line"><span class="comment"> *       yyyy年MM月dd日 HH点mm分钟ss秒  汉字修改,: -  字母表示的每个字段不可以随便写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH点mm分钟ss秒&quot;</span>);</span><br><span class="line">String date = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字符串转为日期对象</strong>用parse</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   DateFormat类方法 parse</span></span><br><span class="line"><span class="comment"> *   将字符串解析为日期对象</span></span><br><span class="line"><span class="comment"> *   Date parse(String s) 字符串变成日期对象</span></span><br><span class="line"><span class="comment"> *   String =&gt; Date parse</span></span><br><span class="line"><span class="comment"> *   Date =&gt; String format</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">function();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  将字符串转成Date对象</span></span><br><span class="line"><span class="comment"> *  DateFormat类方法 parse</span></span><br><span class="line"><span class="comment"> *  步骤:</span></span><br><span class="line"><span class="comment"> *    1. 创建SimpleDateFormat的对象</span></span><br><span class="line"><span class="comment"> *       构造方法中,指定日期模式</span></span><br><span class="line"><span class="comment"> *    2. 子类对象,调用方法 parse 传递String,返回Date</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *    注意: 时间和日期的模式yyyy-MM-dd, 必须和字符串中的时间日期匹配</span></span><br><span class="line"><span class="comment"> *                     1995-5-6</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *    但是,日期是用户键盘输入, 日期根本不能输入</span></span><br><span class="line"><span class="comment"> *    用户选择的形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">Date date = sdf.parse(<span class="string">&quot;1995-5-6&quot;</span>);</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1、基本类型包装类"><a href="#1、基本类型包装类" class="headerlink" title="1、基本类型包装类"></a>1、基本类型包装类</h2><p>用户的输入数据都是字符串类型，然而程序开发过程中需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩转为double类型<br><strong>基本类型包装类</strong>实现的就是将字符串转换成指定的数据类型</p><p>8种基本类型对应的包装类<br>字节型：Byte             byte<br>短整型：Short            short<br>整型：Integer             int<br>长整型：Long             long<br>字符型：Character     char<br>布尔型：Boolean        boolean<br>浮点型：Float             float<br>浮点型：Double         double</p><p>看懂下边的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Integer类,封装基本数据类型int,提高大量方法</span></span><br><span class="line"><span class="comment"> * 将字符串转成基本数据类型int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Integer i = Integer.valueOf(&quot;1&quot;);</span></span><br><span class="line"><span class="comment"> * i.intValue()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Integer类构造方法</span></span><br><span class="line"><span class="comment"> *   Integer (String s)</span></span><br><span class="line"><span class="comment"> *   将数字格式的字符串,传递到Integer类的构造方法中</span></span><br><span class="line"><span class="comment"> *   创建Integer对象,包装的是一个字符串</span></span><br><span class="line"><span class="comment"> *   将构造方法中的字符串,转成基本数据类型,调用方法,非静态的, intValue()</span></span><br><span class="line"><span class="comment"> *  输出： 99  构造方法的格式  in.intValue()转为int类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Integer in = <span class="keyword">new</span> Integer(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> i = in.intValue();</span><br><span class="line">System.out.println(--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  如何将基本类型int,变成字符串</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  int =&gt; String  任何类型+&quot;&quot; 变成String类型</span></span><br><span class="line"><span class="comment"> *  Integer类中的静态方法toString()</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  toString(int ,int 进制), 将int整数,转成指定进制数</span></span><br><span class="line"><span class="comment"> *  0-9A-Z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">String s = i+<span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(s+<span class="number">1</span>); <span class="comment">//输出31这个31是字符串，不是数字32</span></span><br><span class="line"></span><br><span class="line">String s1 = Integer.toString(<span class="number">5</span>,<span class="number">2</span>); <span class="comment">//将5转为二进制数 输出：101</span></span><br><span class="line">System.out.println(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Integer类静态方法parseInt(String s, int radix)</span></span><br><span class="line"><span class="comment"> * radix基数,进制</span></span><br><span class="line"><span class="comment"> * &quot;110&quot;,2 含义 前面的数字是二进制的,但是方法parseInt运行结果都是十进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(<span class="string">&quot;110&quot;</span>, <span class="number">2</span>);      <span class="comment">//表示的是二进制数110，parseInt将二进制数转为十进制数</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Integer类中静态方法 parseInt(String s) 返回基本数据类型</span></span><br><span class="line"><span class="comment"> * 要求: 字符串必须是数字格式的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">System.out.println(i/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Integer类中的其他方法</span></span><br><span class="line"><span class="comment"> *  包括三个方法,和2个静态成员变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Integer类的3个静态方法</span></span><br><span class="line"><span class="comment"> * 做进制的转换</span></span><br><span class="line"><span class="comment"> * 十进制转成二进制  toBinarString(int)</span></span><br><span class="line"><span class="comment"> * 十进制转成八进制  toOctalString(int)</span></span><br><span class="line"><span class="comment"> * 十进制转成十六进制  toHexString(int)</span></span><br><span class="line"><span class="comment"> * 三个方法,返回值都是以String形式出现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(Integer.toBinaryString(<span class="number">99</span>));</span><br><span class="line">System.out.println(Integer.toOctalString(<span class="number">99</span>));</span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">999</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   Integer类的静态成员变量</span></span><br><span class="line"><span class="comment"> *   MAX_VALUE</span></span><br><span class="line"><span class="comment"> *   MIN_VALUE</span></span><br><span class="line"><span class="comment"> *   输出:Integer的最大范围2147483647      -2147483648</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(Integer.MAX_VALUE);</span><br><span class="line">System.out.println(Integer.MIN_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2    基本类型和对象转换<br>使用int类型与Integer对象转换进行演示，其他基本类型转换方式相同。<br>    基本数值—-&gt;包装对象</p><p>Integer i = new Integer(4);//使用构造函数函数<br>Integer ii = new Integer(“4”);//构造函数中可以传递一个数字字符串</p><p>Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法<br>Integer iiii = Integer.valueOf(“4”);//使用包装类中的valueOf方法</p><p>    包装对象—-&gt;基本数值</p><p>int num = i.intValue();<br>1.3    自动装箱拆箱<br>在需要的情况下，基本类型与包装类型可以通用。有些时候我们必须使用引用数据类型时，可以传入基本数据类型。<br>比如：<br>    基本类型可以使用运算符直接进行计算，但是引用类型不可以。而基本类型包装类作为引用类型的一种却可以计算，原因在于，Java”偷偷地”自动地进行了对象向基本数据类型的转换。<br>    相对应的，引用数据类型变量的值必须是new出来的内存空间地址值，而我们可以将一个基本类型的值赋值给一个基本类型包装类的引用。原因同样在于Java又”偷偷地”自动地进行了基本数据类型向对象的转换。<br>    自动拆箱：对象转成基本数值<br>    自动装箱：基本数值转成对象<br>Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);<br>i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5; 加法运算完成后，再次装箱，把基本数值转成对象。</p><p>    自动装箱(byte常量池)细节的演示<br>当数值在byte范围之内时，进行自动装箱，不会新创建对象空间而是使用医来已有的空间。<br>Integer a = new Integer(3);<br>Integer b = new Integer(3);<br>System.out.println(a==b);//false<br>System.out.println(a.equals(b));//true</p><p>System.out.println(“———————“);<br>Integer x = 127;<br>Integer y = 127;<br>//在jdk1.5自动装箱时，如果数值在byte范围之内，不会新创建对象空间而是使用原来已有的空间。<br>System.out.println(x==y); //true<br>System.out.println(x.equals(y)); //true</p><p><strong>自动装箱,拆箱的 好处: 基本类型和引用类直接运算<br>自动装箱和拆箱弊端,可能出现空指针异常</strong></p><p><strong>//数据在byte范围内,JVM不会从新new对象</strong><br>Integer aa = 127; // Integer aa = new Integer(127)++<br>        Integer bb = 127; // Integer bb = aa;<br>        System.out.println(aa==bb); <strong>//true</strong><br>Integer a = 500;<br>        Integer b = 500;<br>        System.out.println(a==b);<strong>//false</strong><br>        System.out.println(a.equals(b));//true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   JDK1.5后出现的特性,自动装箱和自动拆箱</span></span><br><span class="line"><span class="comment"> *   自动装箱: 基本数据类型,直接变成对象</span></span><br><span class="line"><span class="comment"> *   自动拆箱: 对象中的数据变回基本数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  关于自动装箱和拆箱一些题目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(i==j);<span class="comment">// false 对象地址</span></span><br><span class="line">System.out.println(i.equals(j));<span class="comment">// true  继承Object重写equals,比较的对象数据</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">500</span>;</span><br><span class="line">Integer b = <span class="number">500</span>;</span><br><span class="line">System.out.println(a==b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据在byte范围内,JVM不会从新new对象</span></span><br><span class="line">Integer aa = <span class="number">127</span>; <span class="comment">// Integer aa = new Integer(127)</span></span><br><span class="line">Integer bb = <span class="number">127</span>; <span class="comment">// Integer bb = aa;</span></span><br><span class="line">System.out.println(aa==bb); <span class="comment">//true</span></span><br><span class="line">System.out.println(aa.equals(bb));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱和拆箱弊端,可能出现空指针异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer in =<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//in = null.intValue()+1</span></span><br><span class="line">    in = in + <span class="number">1</span>;</span><br><span class="line">    System.out.println(in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱,拆箱的 好处: 基本类型和引用类直接运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//引用类型 , 引用变量一定指向对象</span></span><br><span class="line"><span class="comment">//自动装箱, 基本数据类型1, 直接变成了对象</span></span><br><span class="line"></span><br><span class="line">Integer in = <span class="number">1</span>; <span class="comment">// Integer in = new Integer(1)</span></span><br><span class="line"><span class="comment">//in 是引用类型,不能和基本类型运算, 自动拆箱,引用类型in,转换基本类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//in+1  ==&gt; in.inValue()+1 = 2    </span></span><br><span class="line"><span class="comment">// in = 2    自动装箱</span></span><br><span class="line">in = in + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(in);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ArrayList&lt;Integer&gt; ar = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">    ar. add(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_4();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * System类方法,复制数组</span></span><br><span class="line"><span class="comment"> * arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span></span><br><span class="line"><span class="comment"> * Object src, 要复制的源数组</span></span><br><span class="line"><span class="comment"> * int srcPos, 数组源的起始索引</span></span><br><span class="line"><span class="comment"> * Object dest,复制后的目标数组</span></span><br><span class="line"><span class="comment"> * int destPos,目标数组起始索引 </span></span><br><span class="line"><span class="comment"> * int length, 复制几个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] src = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] desc = &#123;<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.arraycopy(src, <span class="number">1</span>, desc, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;  i &lt; desc.length ; i++)&#123;</span><br><span class="line">System.out.println(desc[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  获取当前操作系统的属性</span></span><br><span class="line"><span class="comment"> *  static Properties getProperties() </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println( System.getProperties() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  JVM在内存中,收取对象的垃圾</span></span><br><span class="line"><span class="comment"> *  static void gc()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">new</span> Person();</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  退出虚拟机,所有程序全停止</span></span><br><span class="line"><span class="comment"> *  static void exit(0)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  获取系统当前毫秒值</span></span><br><span class="line"><span class="comment"> *  static long currentTimeMillis()</span></span><br><span class="line"><span class="comment"> *  对程序执行时间测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3章-Math类"><a href="#第3章-Math类" class="headerlink" title="第3章 Math类"></a>第3章 Math类</h2><p><strong>3.1    概念</strong><br>Math 类是包含用于执行基本数学运算的方法的数学工具类，如初等指数、对数、平方根和三角函数。<br>类似这样的工具类 ，其所有方法均为静态方法，并且一般不会创建对象。如System类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">abs方法,结果都为正数</span><br><span class="line"><span class="keyword">double</span> d1 = Math.abs(-<span class="number">5</span>); <span class="comment">// d1的值为5</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.abs(<span class="number">5</span>); <span class="comment">// d2的值为5</span></span><br><span class="line">ceil方法，结果为比参数值大的最小整数的<span class="keyword">double</span>值</span><br><span class="line"><span class="keyword">double</span> d1 = Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.ceil(-<span class="number">3.3</span>); <span class="comment">//d2的值为 -3.0</span></span><br><span class="line"><span class="keyword">double</span> d3 = Math.ceil(<span class="number">5.1</span>); <span class="comment">// d3的值为 6.0</span></span><br><span class="line">floor方法，结果为比参数值小的最大整数的<span class="keyword">double</span>值</span><br><span class="line"><span class="keyword">double</span> d1 = Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.floor(-<span class="number">3.3</span>); <span class="comment">//d2的值为-4.0</span></span><br><span class="line"><span class="keyword">double</span> d3 = Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br><span class="line">max方法，返回两个参数值中较大的值</span><br><span class="line"><span class="keyword">double</span> d1 = Math.max(<span class="number">3.3</span>, <span class="number">5.5</span>); <span class="comment">//d1的值为5.5</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.max(-<span class="number">3.3</span>, -<span class="number">5.5</span>); <span class="comment">//d2的值为-3.3</span></span><br><span class="line">min方法，返回两个参数值中较小的值</span><br><span class="line"><span class="keyword">double</span> d1 = Math.min(<span class="number">3.3</span>, <span class="number">5.5</span>); <span class="comment">//d1的值为3.3</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.max(-<span class="number">3.3</span>, -<span class="number">5.5</span>); <span class="comment">//d2的值为-5.5</span></span><br><span class="line">pow方法，返回第一个参数的第二个参数次幂的值</span><br><span class="line"><span class="keyword">double</span> d1 = Math.pow(<span class="number">2.0</span>, <span class="number">3.0</span>); <span class="comment">//d1的值为 8.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.pow(<span class="number">3.0</span>, <span class="number">3.0</span>); <span class="comment">//d2的值为27.0</span></span><br><span class="line">round方法，返回参数值四舍五入的结果</span><br><span class="line"><span class="keyword">double</span> d1 = Math.round(<span class="number">5.5</span>); <span class="comment">//d1的值为6.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.round(<span class="number">5.4</span>); <span class="comment">//d2的值为5.0</span></span><br><span class="line">random方法，产生一个大于等于<span class="number">0.0</span>且小于<span class="number">1.0</span>的<span class="keyword">double</span>小数</span><br><span class="line"><span class="keyword">double</span> d1 = Math.random();</span><br></pre></td></tr></table></figure><h2 id="第4章-Arrays类"><a href="#第4章-Arrays类" class="headerlink" title="第4章 Arrays类"></a>第4章 Arrays类</h2><p>.toString .sort .BinarySearch都很实用<br><strong>4.1    概念</strong><br>此类包含用来操作数组（比如排序和搜索）的各种方法。需要注意，如果指定数组引用为 null，则访问此类中的方法都会抛出空指针异常NullPointerException。<br><strong>4.2    常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sort方法，用来对指定数组中的元素进行排序（元素值从小到大进行排序）</span><br><span class="line"><span class="comment">//源arr数组元素&#123;1,5,9,3,7&#125;, 进行排序后arr数组元素为&#123;1,3,5,7,9&#125;</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort( arr );</span><br><span class="line">toString方法，用来返回指定数组元素内容的字符串形式</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">String str = Arrays.toString(arr); <span class="comment">// str的值为[1, 3, 5, 7, 9]</span></span><br><span class="line">binarySearch方法，在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为-<span class="number">1</span>。要求该数组必须是个有序的数组。</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(arr, <span class="number">4</span>); <span class="comment">//index的值为2</span></span><br><span class="line"><span class="keyword">int</span> index2= Arrasy.binarySearch(arr, <span class="number">2</span>); <span class="comment">//index2的值为-1</span></span><br><span class="line"><span class="number">4.3</span>Arrays类的方法练习</span><br><span class="line">练习一：定义一个方法，接收一个数组，数组中存储<span class="number">10</span>个学生考试分数，该方法要求返回考试分数最低的后三名考试分数。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] method(<span class="keyword">double</span>[] arr)&#123;</span><br><span class="line">    Arrays.sort(arr); <span class="comment">//进行数组元素排序（元素值从小到大进行排序）</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//存储后三名考试分数</span></span><br><span class="line">    System.arraycopy(arr, <span class="number">0</span>, result, <span class="number">0</span>, <span class="number">3</span>);<span class="comment">//把arr数组前3个元素复制到result数组中</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  数组的工具类,包含数组的操作</span></span><br><span class="line"><span class="comment"> *  java.util.Arrays</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">56</span>,<span class="number">65</span>,<span class="number">11</span>,<span class="number">98</span>,<span class="number">57</span>,<span class="number">43</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArray = test(arr);</span><br><span class="line">System.out.println(Arrays.toString(newArray));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义方法,接收输入,存储的是10个人考试成绩</span></span><br><span class="line"><span class="comment"> *  将最后三个人的成绩,存储到新的数组中,返回新的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] test(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line"><span class="comment">//对数组排序，默认是从小到大排序</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="comment">//将最后三个成绩存储到新的数组中</span></span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//成绩数组的最后三个元素,复制到新数组中</span></span><br><span class="line">System.arraycopy(arr, <span class="number">0</span>, result, <span class="number">0</span>, <span class="number">3</span>);这种方法可以</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;  i &lt; <span class="number">3</span> ;i++)&#123;</span><br><span class="line">result[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  static String toString(数组)</span></span><br><span class="line"><span class="comment"> *  将数组变成字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">String s = Arrays.toString(arr);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  static int binarySearch(数组, 被查找的元素)</span></span><br><span class="line"><span class="comment"> *  数组的二分搜索法</span></span><br><span class="line"><span class="comment"> *  返回元素在数组中出现的索引</span></span><br><span class="line"><span class="comment"> *  元素不存在, 返回的是  (-插入点-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index =  Arrays.binarySearch(arr, <span class="number">10</span>);</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  static void sort(数组)</span></span><br><span class="line"><span class="comment"> *  对数组升序排列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第5章-大数据运算"><a href="#第5章-大数据运算" class="headerlink" title="第5章 大数据运算"></a>第5章 大数据运算</h2><p><strong>5.1    BigInteger</strong><br>  java中long型为最大整数类型,对于超过long型的数据如何去表示呢.在Java的世界中,超过long型的整数已经不能被称为整数了,它们被封装成BigInteger对象.在BigInteger类中,实现四则运算都是方法来实现,并不是采用运算符.<br>  BigInteger类的构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">构造方法中,采用字符串的形式给出整数</span><br><span class="line">四则运算代码：</span><br><span class="line">/ </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//大数据封装为BigInteger对象</span></span><br><span class="line">          BigInteger big1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12345678909876543210&quot;</span>);</span><br><span class="line">          BigInteger big2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;98765432101234567890&quot;</span>);</span><br><span class="line">          <span class="comment">//add实现加法运算</span></span><br><span class="line">          BigInteger bigAdd = big1.add(big2);   <span class="comment">//表示big1-big2  即调用者是被减数，括号内的参数是减数</span></span><br><span class="line">          <span class="comment">//subtract实现减法运算</span></span><br><span class="line">          BigInteger bigSub = big1.subtract(big2);</span><br><span class="line">          <span class="comment">//multiply实现乘法运算</span></span><br><span class="line">          BigInteger bigMul = big1.multiply(big2);</span><br><span class="line">          <span class="comment">//divide实现除法运算</span></span><br><span class="line">          BigInteger bigDiv = big2.divide(big1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.2    BigDecimal</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在程序中执行下列代码,会出现什么问题?</span><br><span class="line">  System.out.println(<span class="number">0.09</span> + <span class="number">0.01</span>);</span><br><span class="line">  System.out.println(<span class="number">1.0</span> - <span class="number">0.32</span>);</span><br><span class="line">  System.out.println(<span class="number">1.015</span> * <span class="number">100</span>);</span><br><span class="line">  System.out.println(<span class="number">1.301</span> / <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p> double和float类型在运算中很容易丢失精度,造成数据的不准确性,Java提供我们BigDecimal类可以实现浮点数据的高精度运算<br>   构造方法如下:</p><p>  建议浮点数据以字符串形式给出,因为参数结果是可以预知的<br>  实现加法减法乘法代码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//大数据封装为BigDecimal对象</span></span><br><span class="line">      BigDecimal big1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.09&quot;</span>);</span><br><span class="line">      BigDecimal big2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line">      <span class="comment">//add实现加法运算</span></span><br><span class="line">      BigDecimal bigAdd = big1.add(big2);</span><br><span class="line">      </span><br><span class="line">      BigDecimal big3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">      BigDecimal big4 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.32&quot;</span>);</span><br><span class="line">      <span class="comment">//subtract实现减法运算</span></span><br><span class="line">      BigDecimal bigSub = big3.subtract(big4);</span><br><span class="line">      </span><br><span class="line">      BigDecimal big5 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.105&quot;</span>);</span><br><span class="line">      BigDecimal big6 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">      <span class="comment">//multiply实现乘法运算</span></span><br><span class="line">      BigDecimal bigMul = big5.multiply(big6);</span><br></pre></td></tr></table></figure><p>  对于浮点数据的除法运算,和整数不同,可能出现无限不循环小数,因此需要对所需要的位数进行保留和选择舍入模式</p><p> BigDecimal高精度计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BigDecimal实现除法运算</span></span><br><span class="line"><span class="comment"> * divide(BigDecimal divisor, int scale, int roundingMode) </span></span><br><span class="line"><span class="comment"> * int scale : 保留几位小数</span></span><br><span class="line"><span class="comment"> * int roundingMode : 保留模式</span></span><br><span class="line"><span class="comment"> * 保留模式 阅读API文档</span></span><br><span class="line"><span class="comment"> *   static int ROUND_UP  向上+1</span></span><br><span class="line"><span class="comment"> *   static int ROUND_DOWN 直接舍去</span></span><br><span class="line"><span class="comment"> *   static int ROUND_HALF_UP  &gt;= 0.5 向上+1</span></span><br><span class="line"><span class="comment"> *   static int ROUND_HALF_DOWN   &gt; 0.5 向上+1 ,否则直接舍去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0301&quot;</span>);</span><br><span class="line">BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"><span class="comment">//计算b1/b2的商,调用方法divied</span></span><br><span class="line">BigDecimal bigDiv = b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);<span class="comment">//0.01301</span></span><br><span class="line">System.out.println(bigDiv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  BigDecimal实现三则运算</span></span><br><span class="line"><span class="comment"> *  + - *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">BigDecimal b1 =  <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.09&quot;</span>);</span><br><span class="line">BigDecimal b2 =  <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line"><span class="comment">//计算b1+b2的和,调用方法add</span></span><br><span class="line">BigDecimal bigAdd = b1.add(b2);</span><br><span class="line">System.out.println(bigAdd);</span><br><span class="line"></span><br><span class="line">BigDecimal b3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">BigDecimal b4 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.32&quot;</span>);</span><br><span class="line"><span class="comment">//计算b3-b2的差,调用方法subtract</span></span><br><span class="line">BigDecimal bigSub = b3.subtract(b4);</span><br><span class="line">System.out.println(bigSub);</span><br><span class="line"></span><br><span class="line">BigDecimal b5 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.015&quot;</span>);</span><br><span class="line">BigDecimal b6 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"><span class="comment">//计算b5*b6的成绩,调用方法 multiply</span></span><br><span class="line">BigDecimal bigMul = b5.multiply(b6);</span><br><span class="line">System.out.println(bigMul);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算结果,未知</span></span><br><span class="line"><span class="comment"> * 原因: 计算机二进制中,表示浮点数不精确造成</span></span><br><span class="line"><span class="comment"> * 超级大型的浮点数据,提供高精度的浮点运算, BigDecimal</span></span><br><span class="line"><span class="comment">System.out.println(0.09 + 0.01);//0.09999999999999999</span></span><br><span class="line"><span class="comment">System.out.println(1.0 - 0.32);//0.6799999999999999</span></span><br><span class="line"><span class="comment">System.out.println(1.015 * 100);//101.49999999999999</span></span><br><span class="line"><span class="comment">System.out.println(1.301 / 100);//0.013009999999999999 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="集合ArrayList-util包下面"><a href="#集合ArrayList-util包下面" class="headerlink" title="集合ArrayList  util包下面"></a>集合ArrayList  util包下面</h2><p>集合不存储基本类型，只存储引用类型（即，对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  集合体系,</span></span><br><span class="line"><span class="comment"> *    目标  集合本身是一个存储的容器:</span></span><br><span class="line"><span class="comment"> *       必须使用集合存储对象</span></span><br><span class="line"><span class="comment"> *       遍历集合,取出对象</span></span><br><span class="line"><span class="comment"> *       集合自己的特性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  集合ArrayList,存储int类型数</span></span><br><span class="line"><span class="comment"> *  集合本身不接受基本类,自动装箱存储</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">array.add(<span class="number">11</span>);</span><br><span class="line">array.add(<span class="number">12</span>);</span><br><span class="line">array.add(<span class="number">13</span>);</span><br><span class="line">array.add(<span class="number">14</span>);</span><br><span class="line">array.add(<span class="number">15</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.size() ;i++)&#123;</span><br><span class="line">System.out.println(array.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  集合存储自定义的Person类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;Person&gt; arrayPer = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); <span class="comment">//ArrayList&lt;类名&gt; ArrayList对象名 = new ArrayList&lt;类名&gt;(构造方法)</span></span><br><span class="line"> - arrayPer.add(<span class="keyword">new</span> Person(<span class="string">&quot;a&quot;</span>,<span class="number">20</span>));</span><br><span class="line">arrayPer.add(<span class="keyword">new</span> Person(<span class="string">&quot;b&quot;</span>,<span class="number">18</span>));</span><br><span class="line">arrayPer.add(<span class="keyword">new</span> Person(<span class="string">&quot;c&quot;</span>,<span class="number">22</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arrayPer.size();i++)&#123;</span><br><span class="line"><span class="comment">//get(0),取出的对象Person对象</span></span><br><span class="line"><span class="comment">//打印的是一个对象,必须调用的toString()</span></span><br><span class="line">System.out.println(arrayPer.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口，Colection接口为最顶层集合接口<br><img src="https://img-blog.csdnimg.cn/20201212213024871.png![%E5%9C%A8%E8%BF%99%E9%87%8C%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0](https://img-blog.csdnimg.cn/20201212213048851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201211203120688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Collection接口概述<br>    既然Collection接口是集合中的顶层接口，那么他中定义的所有功能子类都可以使用。查阅API中描述的Collection接口。Collection层次结构中的根接口。Collection表示一组对象，这些对象也成为Collection的元素。一些Collection允许有重复的元素，而另一些则不允许。一些Collecion接口是有序的，另一些是无序的。<br><img src="https://img-blog.csdnimg.cn/20201207224058187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201212215021221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Collection接口中的方法</span></span><br><span class="line"><span class="comment"> *  是集合中所有实现类必须拥有的方法</span></span><br><span class="line"><span class="comment"> *  使用Collection接口的实现类,程序的演示</span></span><br><span class="line"><span class="comment"> *  ArrayList implements List</span></span><br><span class="line"><span class="comment"> *  List extends Collection</span></span><br><span class="line"><span class="comment"> *  方法的执行,都是实现的重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Collection接口方法</span></span><br><span class="line"><span class="comment"> * boolean remove(Object o)移除集合中指定的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(coll);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = coll.remove(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(coll);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Collection接口方法</span></span><br><span class="line"><span class="comment"> *  Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组</span></span><br><span class="line"><span class="comment"> *  返回是一个存储对象的数组, 数组存储的数据类型是Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">Object[] objs = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; objs.length ; i++)&#123;</span><br><span class="line">System.out.println(objs[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 学习Java中三种长度表现形式</span></span><br><span class="line"><span class="comment"> *   数组.length 属性  返回值 int</span></span><br><span class="line"><span class="comment"> *   字符串.length() 方法,返回值int</span></span><br><span class="line"><span class="comment"> *   集合.size()方法, 返回值int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Collection接口方法</span></span><br><span class="line"><span class="comment"> * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true</span></span><br><span class="line"><span class="comment"> * 方法参数是Object类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = coll.contains(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Collection接口的方法</span></span><br><span class="line"><span class="comment"> * void clear() 清空集合中的所有元素</span></span><br><span class="line"><span class="comment"> * 集合容器本身依然存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//接口多态的方式调用</span></span><br><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line">System.out.println(coll);</span><br><span class="line"></span><br><span class="line">coll.clear();</span><br><span class="line"></span><br><span class="line">System.out.println(coll);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h2><p><img src="https://img-blog.csdnimg.cn/202012122158083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  集合中的迭代器:</span></span><br><span class="line"><span class="comment"> *    获取集合中元素方式</span></span><br><span class="line"><span class="comment"> *  接口 Iterator : 两个抽象方法</span></span><br><span class="line"><span class="comment"> *     boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true</span></span><br><span class="line"><span class="comment"> *     next() 取出集合中的下一个元素</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *  Iterator接口,找实现类.</span></span><br><span class="line"><span class="comment"> *    Collection接口定义方法 </span></span><br><span class="line"><span class="comment"> *       Iterator  iterator()</span></span><br><span class="line"><span class="comment"> *    ArrayList 重写方法 iterator(),返回了Iterator接口的实现类的对象</span></span><br><span class="line"><span class="comment"> *    使用ArrayList集合的对象</span></span><br><span class="line"><span class="comment"> *     Iterator it = array.iterator(),运行结果就是Iterator接口的实现类的对象</span></span><br><span class="line"><span class="comment"> *     it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line"><span class="comment">//迭代器,对集合ArrayList中的元素进行取出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用集合的方法iterator()获取出,Iterator接口的实现类的对象</span></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="comment">//接口实现类对象,调用方法hasNext()判断集合中是否有元素</span></span><br><span class="line"><span class="comment">//boolean b = it.hasNext();</span></span><br><span class="line"><span class="comment">//System.out.println(b);</span></span><br><span class="line"><span class="comment">//接口的实现类对象,调用方法next()取出集合中的元素</span></span><br><span class="line"><span class="comment">//String s = it.next();</span></span><br><span class="line"><span class="comment">//System.out.println(s);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">String s = it.next();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*for (Iterator&lt;String&gt; it2 = coll.iterator(); it2.hasNext();  ) &#123;</span></span><br><span class="line"><span class="comment">System.out.println(it2.next());</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="增强for循环-ForEachDemo"><a href="#增强for循环-ForEachDemo" class="headerlink" title="增强for循环 ForEachDemo"></a>增强for循环 ForEachDemo</h2><p>JDK1.5以后的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作，不能进行排序等操作，因为没有索引，不能操作容器里面的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo2;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  JDK1.5新特性,增强for循环</span></span><br><span class="line"><span class="comment"> *  JDK1.5版本后,出现新的接口 java.lang.Iterable</span></span><br><span class="line"><span class="comment"> *    Collection开是继承Iterable</span></span><br><span class="line"><span class="comment"> *    Iterable作用,实现增强for循环</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *    格式:</span></span><br><span class="line"><span class="comment"> *      for( 数据类型  变量名 : 数组或者集合 )&#123;</span></span><br><span class="line"><span class="comment"> *         sop(变量);</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> cn.itcast.demo.Person;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  增强for循环遍历集合</span></span><br><span class="line"><span class="comment"> *  存储自定义Person类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">ArrayList&lt;Person&gt; array = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">array.add(<span class="keyword">new</span> Person(<span class="string">&quot;a&quot;</span>,<span class="number">20</span>));</span><br><span class="line">array.add(<span class="keyword">new</span> Person(<span class="string">&quot;b&quot;</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">for</span>(Person p : array)&#123;</span><br><span class="line">System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//for对于对象数组遍历的时候,能否调用对象的方法呢</span></span><br><span class="line">String[] str = &#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;cn&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String s : str)&#123;     <span class="comment">//for(类型 变量名： 数组名)</span></span><br><span class="line">System.out.println(s.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  实现for循环,遍历数组</span></span><br><span class="line"><span class="comment"> *  好处: 代码少了,方便对容器遍历</span></span><br><span class="line"><span class="comment"> *  弊端: 没有索引,不能操作容器里面的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">System.out.println(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>用于解决类型转换异常的安全问题<br><img src="https://img-blog.csdnimg.cn/20201212224851975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>泛型: 指明了集合中存储数据的类型  &lt;数据类型&gt;</strong><br>    Collection<String> coll = new ArrayList<String>();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JDK1.5 出现新的安全机制,保证程序的安全性</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();   <span class="comment">//这句话就是泛型，指明col1存储的对象类型是String</span></span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;rtyg&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;43rt5yhju&quot;</span>);</span><br><span class="line"><span class="comment">//coll.add(1);</span></span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">String s = it.next();</span><br><span class="line">System.out.println(s.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-List接口中常用的方法"><a href="#1-2-List接口中常用的方法" class="headerlink" title="1.2 List接口中常用的方法"></a>1.2 List接口中常用的方法</h2><p>    增加元素方法<br>        add(Object e)：向集合末尾处，添加指定的元素<br>        add(int index, Object e)：向集合指定索引处，添加指定的元素，原有元素依次后移<br>    删除元素删除<br>        remove(Object e)：将指定元素对象，从集合中删除，返回值为被删除的元素<br>        remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素<br>    替换元素方法<br>        set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素<br>    查询元素方法<br>        get(int index)：获取指定索引处的元素，并返回该元素</p><p><img src="https://img-blog.csdnimg.cn/20210115092944692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  List接口派系, 继承Collection接口</span></span><br><span class="line"><span class="comment"> *    下面有很多实现类</span></span><br><span class="line"><span class="comment"> *  List接口特点: 有序,索引,可以重复元素</span></span><br><span class="line"><span class="comment"> *    实现类, ArrayList, LinkedList</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *  List接口中的抽象方法,有一部分方法和他的父接口Collection是一样</span></span><br><span class="line"><span class="comment"> *  List接口的自己特有的方法, 带有索引的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  E set(int index, E)</span></span><br><span class="line"><span class="comment"> *  修改指定索引上的元素</span></span><br><span class="line"><span class="comment"> *  返回被修改之前的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Integer i = list.set(<span class="number">0</span>, <span class="number">5</span>);  将<span class="number">0</span>索引上的值改为<span class="number">5</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  E remove(int index)</span></span><br><span class="line"><span class="comment"> *  移除指定索引上的元素</span></span><br><span class="line"><span class="comment"> *  返回被删除之前的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">list.add(<span class="number">1.1</span>);</span><br><span class="line">list.add(<span class="number">1.2</span>);</span><br><span class="line">list.add(<span class="number">1.3</span>);</span><br><span class="line">list.add(<span class="number">1.4</span>);</span><br><span class="line"></span><br><span class="line">Double d = list.remove(<span class="number">0</span>);  删除的是<span class="number">0</span>索引上的<span class="number">1.1</span>  remove方法返回被删除的值<span class="number">1.1</span></span><br><span class="line">System.out.println(d);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  add(int index, E)</span></span><br><span class="line"><span class="comment"> *  将元素插入到列表的指定索引上</span></span><br><span class="line"><span class="comment"> *  带有索引的操作,防止越界问题</span></span><br><span class="line"><span class="comment"> *  java.lang.IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *     ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *     StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">1</span>, <span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-1-Iterator的并发修改异常"><a href="#1-2-1-Iterator的并发修改异常" class="headerlink" title="1.2.1 Iterator的并发修改异常"></a>1.2.1 Iterator的并发修改异常</h2><p>简单描述：  我一边遍历你一边加东西  就会报错<br><strong>迭代器工作的时候，不能修改集合的长度</strong><br>/*</p><ul><li> 迭代器的并发修改异常 java.util.ConcurrentModificationException</li><li> 就是在遍历的过程中,使用了集合方法修改了集合的长度,不允许的</li><li>/<br>运行上述代码发生了错误 java.util.ConcurrentModificationException 这是什么原因呢？<br>在迭代过程中，使用了集合的方法对元素进行操作。导致迭代器并不知道集合中的变化，容易引发数据的不确定性。<br>并发修改异常解决办法：在迭代时，不要使用集合的方法操作元素。<br>那么想要在迭代时对元素操作咋办？通过ListIterator迭代器操作元素是可以的，ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  迭代器的并发修改异常 java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> *  就是在遍历的过程中,使用了集合方法修改了集合的长度,不允许的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对集合使用迭代器进行获取,获取时候判断集合中是否存在 &quot;abc3&quot;对象</span></span><br><span class="line"><span class="comment">//如果有,添加一个元素 &quot;ABC3&quot;</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">String s = it.next();</span><br><span class="line"><span class="comment">//对获取出的元素s,进行判断,是不是有&quot;abc3&quot;</span></span><br><span class="line"><span class="keyword">if</span>(s.equals(<span class="string">&quot;abc3&quot;</span>))&#123;  不能用s == <span class="string">&quot;abc3&quot;</span>来判断   字符串</span><br><span class="line">list.add(<span class="string">&quot;ABC3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">各个数据结构的特点：</span><br><span class="line">**堆栈**，采用该结构的集合，对元素的存取有如下的特点：</span><br><span class="line">先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</span><br><span class="line">栈的入口、出口的都是栈的顶端位置</span><br><span class="line">压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</span><br><span class="line">弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</span><br><span class="line">**队列**，采用该结构的集合，对元素的存取有如下的特点：</span><br><span class="line">先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，安检。排成一列，每个人依次检查，只有前面的人全部检查完毕后，才能排到当前的人进行检查。</span><br><span class="line">队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</span><br><span class="line">**数组**，采用该结构的集合，对元素的存取有如下的特点：</span><br><span class="line">*查找元素快*：通过索引，可以快速访问指定位置的元素</span><br><span class="line">*增删元素慢*：</span><br><span class="line">指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图</span><br><span class="line">指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中</span><br><span class="line">**链表**，采用该结构的集合，对元素的存取有如下的特点：</span><br><span class="line">多个节点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</span><br><span class="line">*查找元素慢*：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</span><br><span class="line">*增删元素快*：</span><br><span class="line">增加元素：操作如左图，只需要修改连接下个元素的地址即可。</span><br><span class="line">删除元素：操作如右图，只需要修改连接下个元素的地址即可。</span><br></pre></td></tr></table></figure><p>ArrayList是一个数组列表<br>元素增删慢 查找快<br><img src="https://img-blog.csdnimg.cn/20210115103445121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021011510345255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-5-LinkedList集合"><a href="#1-5-LinkedList集合" class="headerlink" title="1.5 LinkedList集合"></a>1.5 LinkedList集合</h2><p>LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。如下图<br><img src="https://img-blog.csdnimg.cn/20210115104037449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  LinkedList 链表集合的特有功能</span></span><br><span class="line"><span class="comment"> *    自身特点: 链表底层实现,查询慢,增删快</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  子类的特有功能,不能多态调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  E removeFirst() 移除并返回链表的开头</span></span><br><span class="line"><span class="comment"> *  E removeLast() 移除并返回链表的结尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">link.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">String first = link.removeFirst();</span><br><span class="line">String last = link.removeLast();</span><br><span class="line">System.out.println(first);</span><br><span class="line">System.out.println(last);</span><br><span class="line"></span><br><span class="line">System.out.println(link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * E getFirst() 获取链表的开头</span></span><br><span class="line"><span class="comment"> * E getLast() 获取链表的结尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">link.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    <span class="comment">//link.clear();清空操作</span></span><br><span class="line"><span class="keyword">if</span>(!link.isEmpty())&#123;</span><br><span class="line">String first = link.getFirst();</span><br><span class="line">String last = link.getLast();</span><br><span class="line">System.out.println(first);</span><br><span class="line">System.out.println(last);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">link.addLast(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">link.addLast(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">link.addLast(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">link.addLast(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">link.addFirst(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">link.addFirst(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">link.addFirst(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">System.out.println(link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  addFirst(E) 添加到链表的开头</span></span><br><span class="line"><span class="comment"> *  addLast(E) 添加到链表的结尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">link.addLast(<span class="string">&quot;heima&quot;</span>);</span><br><span class="line"></span><br><span class="line">link.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line"></span><br><span class="line">link.addFirst(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">System.out.println(link);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-6-Vector集合"><a href="#1-6-Vector集合" class="headerlink" title="1.6 Vector集合"></a>1.6 Vector集合</h2><p>Vector集合数据存储的结构是数组结构，为JDK中最早提供的集合。Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。此接口Enumeration的功能与 Iterator 接口的功能是类似的。Vector集合已被ArrayList替代。枚举Enumeration已被迭代器Iterator替代。<br><img src="https://img-blog.csdnimg.cn/20210115105807211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>1、println和printf以及print区别</strong><br>print和prinln的区别     后者自带换行功能<br>printf–函数，把文字格式化以后输出，直接调用系统调用进行IO的，他是非缓冲的。<br><strong>2、Integer和int的区别</strong></p><p>1、Integer是int提供的封装类，而int是Java的基本数据类型；<br>2、Integer默认值是null，而int默认值是0；<br>3、声明为Integer的变量需要实例化，而声明为int的变量不需要实例化；<br>4、Integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">通过数组转为链表，以及通过键盘输入链表  考试可能第一种偏多</span><br><span class="line"></span><br><span class="line">合并两个链表代码</span><br><span class="line"><span class="keyword">package</span> leetcode1230;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNodeMOBAN</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String line = in.nextLine();</span><br><span class="line">Scanner in2 = <span class="keyword">new</span> Scanner(line);</span><br><span class="line"><span class="comment">//数组转链表</span></span><br><span class="line">ListNode l5 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">ListNode cur3 = l5;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">l5.next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">l5 = l5.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表1</span></span><br><span class="line">ListNode l4 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">ListNode cur2 = l4;</span><br><span class="line"><span class="keyword">while</span>(in2.hasNextInt())&#123;</span><br><span class="line">     l4.next = <span class="keyword">new</span> ListNode(in2.nextInt());</span><br><span class="line">     l4 = l4.next;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ListNode ret2 = mergeTwoLists(cur2.next,cur3.next);</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;l1和l4&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(ret2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d  &quot;</span>,ret2.val);</span><br><span class="line">ret2 = ret2.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; ++i) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a != <span class="keyword">null</span> ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tail = head, aPtr = a, bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr != <span class="keyword">null</span> &amp;&amp; bPtr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">                tail.next = aPtr;</span><br><span class="line">                aPtr = aPtr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = bPtr;</span><br><span class="line">                bPtr = bPtr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = (aPtr != <span class="keyword">null</span> ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/04/18/day03%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/18/day03%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>今日内容介绍<br>1、引用类型变量的创建及使用<br>2、流程控制语句之选择语句<br>3、流程控制语句之循环语句<br>4、循环高级</p><p>###01创建引用类型变量公式<br>    * A: 创建引用类型变量公式<br>        * a: 我们要学的Scanner类是属于引用数据类型，我们先了解下引用数据类型。<br>        * b: 引用数据类型的定义格式<br>            * 与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式。<br>            * 数据类型  变量名  =  new 数据类型();<br>        * c: 引用数据类型的使用<br>            * 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。<br>            * 变量名.方法名();</p><p>###02Scanner类的使用<br>    * A: Scanner类的使用<br>        * a: 导包import java.util.Scanner;<br>        * b：创建键盘录入对象 Scanner sc = new Scanner(System.in);<br>        * c: 读取键盘录入的一个整数<br>            * int enterNumber = sc.nextInt();<br>        * d: 读取键盘录入的字符串<br>            * String enterString = sc.next();<br>    * B: 案例代码<br>        import java.util.Scanner;<br>        public class Demo05Scanner{<br>            public static void main(String[] args)<br>            {<br>                Scanner sc = new Scanner(System.in);</p><pre><code>            int enterNumber = sc.nextInt();            System.out.println(&quot;用户输入的整数为&quot;+enterNumber);            String enterString = sc.next();            System.out.println(&quot;用户输入的字符串为&quot;+enterString);        &#125;    &#125;                </code></pre><p>###03Random随机数类的使用_1<br>    * A: Random随机数类的使用_1<br>        * a: 功能<br>            * 生成随机数需要使用到引用类型随机数Random类<br>        * b: 使用方式<br>            * import导包：所属包java.util. Random<br>            * 创建实例格式：Random  random = new Random ();<br>            * 调用方法<br>                * nextInt(int maxValue)    产生[0,maxValue)范围的随机数,包含0不包含maxValue<br>                * nextDouble()  产生[0,1)范围的随机数<br>                如：<br>                    Random  random = new Random ();<br>                    int  myNumber = random.nextInt(100);//结果为0-99的一个数<br>    * B: 案例代码<br>        import java.util.Random;<br>        public class RandomDemo{<br>            public static void main(String[] args){<br>               Random ran = new Random();<br>               // Random类中的,产生随机数的功能<br>               int i = ran.nextInt(100);<br>               System.out.println(i);</p><pre><code>           //问题? 产生随机数,范围 1-100之间           // nextInt(100) 0-99 + 1        &#125;    &#125;</code></pre><p>###04Random随机数类的使用_2<br>    * A: Random随机数类的使用_2<br>        * a: 调用方法<br>            * nextDouble()  产生[0,1)范围的随机数<br>            如：<br>                Random  random = new Random ();<br>                int  myNumber = random.nextDouble();//结果为0.0-1.0之间的数(包括0.0不包括1.0)</p><p>###05if语句格式第一种<br>    * A: if语句格式第一种<br>        * a: 书写格式<br>            if(比较表达式) {<br>                语句体;<br>            }<br>        * b：执行流程：<br>            * 先计算比较表达式的值，看其返回值是true还是false。<br>            * 如果是true，就执行语句体；<br>            * 如果是false，就不执行语句体；<br>    * B: 案例代码<br>        public class IfDemo{<br>            public static void main(String[] args){<br>                  int i = 5 ;<br>                  //对变量i进行if判断<br>                  if(i &gt; 5){<br>                      System.out.println(“if中的条件是true”);<br>                      i++;<br>                  }</p><pre><code>              System.out.println(i);        &#125;    &#125;                </code></pre><p>###06if语句格式第二种<br>    * A: if语句格式第二种<br>        * a: 书写格式<br>            if(比较表达式) {<br>                语句体1;<br>            }else {<br>                语句体2;<br>            }<br>        * b：执行流程：<br>            * 首先计算比较表达式的值，看其返回值是true还是false。<br>            * 如果是true，就执行语句体1；<br>            * 如果是false，就执行语句体2；<br>    * B: 案例代码<br>        public class IfElseDemo{<br>            public static void main(String[] args){<br>                 int i = 16 ;<br>                 //判断变量,是奇偶数, 除以2,看余数是0还是1<br>                 if( i % 2 == 0 ){<br>                     System.out.println(i+” 是偶数”);<br>                 }else{<br>                     System.out.println(i+” 是奇数”);<br>                 }<br>            }<br>        }</p><p>###07if语句格式第三种<br>    * A: if语句格式第三种<br>        * a: 书写格式<br>                if(比较表达式1) {<br>                    语句体1;<br>                }else if(比较表达式2) {<br>                    语句体2;<br>                }else if(比较表达式3) {<br>                    语句体3;<br>                }<br>                …<br>                else {<br>                    语句体n+1;<br>                }<br>        * b：执行流程：<br>            * 首先计算比较表达式1看其返回值是true还是false，<br>            * 如果是true，就执行语句体1，if语句结束。<br>            * 如果是false，接着计算比较表达式2看其返回值是true还是false，</p><pre><code>        * 如果是true，就执行语句体2，if语句结束。        * 如果是false，接着计算比较表达式3看其返回值是true还是false，                * 如果都是false，就执行语句体n+1。* B: 案例代码    public class IfElseIfDemo&#123;        public static void main(String[] args)&#123;            //成绩判断要求 ,成绩&gt;80  成绩&gt;70  成绩&gt;60  不及格            //定义变量,保存成绩            int grade = 75;            //使用if else if 语句对成绩判断            if( grade &gt; 80 )&#123;                System.out.println(grade+&quot; 成绩是优&quot;);            &#125;else if ( grade &gt; 70)&#123;                System.out.println(grade+&quot; 成绩是良&quot;);            &#125;else if ( grade &gt; 60)&#123;                System.out.println(grade+&quot; 成绩是中&quot;);            &#125;else&#123;                System.out.println(grade+&quot; 成绩是差&quot;);            &#125;                     &#125;    &#125;</code></pre><p>###08if语句和三元运算符的互换<br>    * A: 三元运算符<br>        * a: 概念<br>            * 用来完成简单的选择逻辑，即根据条件判断，从两个选择中选择一种执行<br>        * b: 使用格式<br>            * (条件表达式)？表达式1：表达式2；<br>        * c: 运算规则<br>            * 1: 判断条件表达式，结果为一个布尔值<br>            * 2: true，运算结果为表达式1<br>            * 3: false，运算结果为表达式2<br>    * B: 案例代码<br>        public class IfElseDemo_1{<br>            public static void main(String[] args){<br>                int j = 6;<br>                int i = 15;<br>                //使用if语句,判断出最大值<br>                if(i&gt;j){<br>                int j = 6;<br>                    System.out.println(i+” 是最大值”);<br>                }else{<br>                    System.out.println(j+” 是最大值”);<br>                }</p><pre><code>            //使用三元运算实现            int k = i&gt;j ? i : j;            System.out.println(k+&quot; 是最大值&quot;);        &#125;    &#125;* C: 使用if语句还是三元表达式    * 判断条件多,使用if     * 三元,必须有结果的, if 可以没有结果的</code></pre><p>###09while循环<br>    * A: while循环结构<br>        * a: 使用格式<br>            初始化表达式；<br>            while(条件){<br>                循环体<br>            }<br>        * b: 执行顺序<br>              当条件是true,就执行循环体,执行完循环体后<br>              程序再次执行while中的条件,如果条件还是true,继续执行循环体<br>              直到条件是false的时候,循环就结束<br>    * B: 案例代码<br>        public class WhileDemo{<br>            public static void main(String[] args){<br>                //输出 1-4之间的整数<br>                //定义变量,整数类型, 循环的条件<br>                int i = 1;<br>                while( i &lt; 5 ){<br>                    System.out.println(i);<br>                    i++;<br>                }<br>            }<br>        }</p><p>###10for循环_1<br>    * A: for循环_1<br>        * a: 使用格式<br>             for(初始化变量 ; 条件 ; 增量){<br>                 循环体;<br>             }<br>        * b: 各模块解释<br>            初始化变量: 定义变量,作用是用来控制循环的次数<br>            条件: 当条件是true,执行循环体,条件是false,结束循环<br>            增量: 变量自增情况<br>    * B: 案例代码<br>        public class ForDemo{<br>            public static void main(String[] args){<br>                //for循环,输出0-10<br>                for(int i = 0 ; i &lt; 11 ; i++){<br>                    System.out.println(i);<br>                }<br>            }<br>        }</p><p>###11for循环_2<br>    * A: for循环的执行流程<br>        for（① ; ② ; ③）{<br>            ④<br>        }<br>        第一步，执行①<br>        第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步<br>        第三步，执行④<br>        第四步，执行③，然后重复执行第二步<br>        第五步，退出循环</p><p>###12for循环_3<br>    * A: 案例<br>        * a: 利用for循环,计算1+4的结果<br>    * B: 案例代码<br>        public class ForDemo_1{<br>            public static void main(String[] args){<br>                // 定义变量,记录求和后的数据<br>                int sum = 0;<br>                // 利用循环,将变量从1变化到4<br>                for(int i = 1 ; i &lt;= 4 ; i++){<br>                    //对变量进行求和<br>                    sum = sum + i;<br>                }<br>                System.out.println(sum);<br>            }<br>        }</p><p>###13do_while循环<br>    * A: do_while循环<br>        * a: 使用格式<br>            do{<br>               循环体;<br>            }while(条件);<br>        * b: 执行顺序<br>            先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体，<br>            如果条件为false，循环结束。<br>        * c: 特点<br>            * 无条件先执行一次<br>    * B: 案例代码<br>        public class DoWhileDemo{<br>            public static void main(String[] args){<br>                int i = 0;<br>                do{<br>                    System.out.println(i);<br>                    i++;<br>                }while( i &lt;  5);<br>            }<br>        }</p><p>###14死循环<br>    * A: 死循环概述<br>        * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环<br>    * B: 死循环格式<br>        * while(true){}<br>        * for(;;){}</p><p>###15嵌套for循环_1<br>    * A: 嵌套循环的概述<br>        * 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的在for循环中嵌套for循环。<br>    * B: 嵌套循环的格式<br>        for(初始化表达式; 循环条件; 操作表达式) {<br>            ………<br>            for(初始化表达式; 循环条件; 操作表达式) {<br>                执行语句<br>                ………<br>            }<br>            ………<br>        }<br>    * C: 各模块解释<br>        * 总的循环次数 =  内循环次数 * 外循环的次数<br>        * 内循环,是外循环的循环体</p><pre><code>    * 外循环,控制的是行数    * 内循环,控制的是每行的个数</code></pre><p>###16嵌套for循环_2<br>    * A: 案例<br>        * a: 打印正三角形<br>    * B: 案例代码<br>        public class ForForDemo{<br>            public static void main(String[] args){<br>                for(int i = 0 ; i &lt; 9 ; i++){<br>                    for(int j = 0; j &lt; i+1 ;j++){<br>                        System.out.print(“* “);<br>                    }<br>                    System.out.println();<br>                }<br>            }<br>        }</p><p>###17break语句<br>    * A: break语句<br>        * a: 作用<br>            * 跳出所在的循环体<br>        * b: 书写位置<br>            * 必须出现在循环或选择结构内<br>        * c: 举例<br>            for(int i=0; i&lt;10; i++) {<br>                if(i&gt;5) {<br>                break;<br>            }<br>                System.out.println(“我爱Java”+i);<br>            }<br>            //会从0-5输出6次“我爱Java”<br>    * B: break详细解释<br>        * a: 作用<br>            * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中，<br>                可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码，<br>                这些关键字一旦出现就可以跳转语句执行顺序。<br>        * b: 使用方式<br>            * 无法单独使用，必须将break关键字置于switch或循环语句中<br>        * c: 运行规律<br>            * 不需要判断任何条件，只要遇到break变直接跳出执行后续代码。会完全跳出选择或者循环结构<br>            * 只能跳出最近的代码块，不能跨越多级代码块</p><pre><code>* C：循环标号    * a: 为什么使用循环标号        * 当在双层循环或者循环内有switch选择语句时，我们发现，使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了.    * b: 使用方式        * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。          使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可    * c: 运行规律        * 当外层循环外定义了标号        * 内层使用break，终止内外双层循环。        * 内层使用continue，终止内层循环，继续外层循环。</code></pre><p>###18continue语句<br>    * A: continue语句<br>        * a: 作用<br>            * 提前结束本次循环，继续进行下次循环<br>        * b: 使用方式<br>            * 无法单独使用，必须将continue关键字置于循环语句中<br>        * c：运行规律<br>            * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环<br>        * d：案例代码<br>            public class ContinueDemo{<br>                public static void main(String[] args){<br>                    for(int i = 0 ; i &lt; 10 ; i++){<br>                        if(i%2==0){<br>                            continue;<br>                        }<br>                        System.out.println(i);<br>                    }<br>                }<br>            }<br>            //会把0-9之间所有的奇数打印到控制台上</p><p>###19猜数字小游戏<br>    * A: 猜数字小游戏<br>        * a: 分析<br>            * 用户给的数可能大于、小于、或等于被猜的数，这样就会出现三种情况，用前面讲的三元运算符可以实现，<br>                但是得用三元运算符的嵌套，比较麻烦！可以用更简单的方式if条件判断，可以有三个以上的条件<br>        * b: 需求分析<br>            * 后台预先生成一个随机数1-100，用户键盘录入猜数字<br>            * 如果猜对了，打印“恭喜您，答对了”<br>            * 如果猜错了<br>            * 猜大了：打印“sorry，您猜大了!”<br>            * 猜小了：打印“sorry，您猜小了!”<br>                    直到数字猜到为止<br>                    最多只能猜5次，否则提示“sorry，您没有机会了!”<br>    * B: 案例代码<br>        /*<br>            猜数字小游戏</p><pre><code>        完成猜数字小游戏：        1、产生随机数        后台预先生成一个随机数1-100，用户键盘录入猜数字        2、通过if语句对用户猜的数与随机数进行比较        如果猜对了，打印“恭喜您，答对了”        如果猜错了        猜大了：打印“sorry，您猜大了!”        猜小了：打印“sorry，您猜小了!”        3、通过for循环完成用户猜数的循环        直到数字猜到为止        最多只能猜5次，否则提示“sorry，您没有机会了!”    */    import java.util.Random;    import java.util.Scanner;    //通过*的方式可以一次导入该包下所有的类，但是不建议使用。建议使用哪个导哪个。    //import java.util.*;    public class GuessNumber&#123;        public static void main(String[] args) &#123;            //1、产生随机数            //后台预先生成一个随机数1-100，用户键盘录入猜数字            //创建随机数对象            Random random = new Random();            //产生一个1-100的随机数            int randomNumber = random.nextInt(100)+1;            //System.out.println(&quot;我产生的随机数是：&quot;+randomNumber+&quot;你猜猜是多少？&quot;);  作弊专用            //产生控制台录入的Scanner对象            Scanner sc = new Scanner(System.in);            //3、通过for循环完成用户猜数的循环            //通过for循环完成猜数字逻辑            for(int i=1; i&lt;=5; i++)&#123;                //提示用户输入要猜的数，用变量接收                System.out.println();                System.out.println(&quot;请您输入一个1-100的数：&quot;);                int guessNumber = sc.nextInt();                                //2、通过if语句对用户猜的数与随机数进行比较                //如果猜对了                if(guessNumber==randomNumber) &#123;                    //打印猜对后的提示                    System.out.println(&quot;恭喜您，猜对了！&quot;);                    //跳出循环，不用再猜了                    break;                &#125;else &#123;//如果猜错了                    //如果猜大了                    if(guessNumber&gt;randomNumber) &#123;                        System.out.println(&quot;sorry，您猜大了!&quot;);                    &#125;else &#123;//如果猜小了                        System.out.println(&quot;sorry，您猜小了!&quot;);                    &#125;                &#125;                //如果猜到了最后的第5次仍然没有猜对就跳出循环                if(i==5) &#123;                    System.out.println(&quot;对不起，点太背，下次再来吧！&quot;);                    break;                &#125;                //每次猜错后，都提示还有多少次机会                System.out.println(&quot;请注意，您还有&quot;+(5-i)+&quot;次机会，请慎重作答！&quot;);            &#125;        &#125;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/17/hello-world/"/>
      <url>2021/04/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
